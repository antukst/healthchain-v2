{"version":3,"file":"matic.umd.min.js","mappings":"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","sources":["webpack://matic/webpack/universalModuleDefinition","webpack://matic/./node_modules/safe-buffer/index.js","webpack://matic/external umd \"@ethereumjs/block\"","webpack://matic/external umd \"@ethereumjs/common\"","webpack://matic/external umd \"@ethereumjs/trie\"","webpack://matic/external umd \"@ethereumjs/util\"","webpack://matic/external umd \"bn.js\"","webpack://matic/external umd \"buffer\"","webpack://matic/external umd \"node-fetch\"","webpack://matic/external umd \"rlp\"","webpack://matic/webpack/bootstrap","webpack://matic/webpack/runtime/compat get default export","webpack://matic/webpack/runtime/define property getters","webpack://matic/webpack/runtime/hasOwnProperty shorthand","webpack://matic/webpack/runtime/make namespace object","webpack://matic/./src/abstracts/contract_method.ts","webpack://matic/./src/enums/log_event_signature.ts","webpack://matic/./src/enums/error_type.ts","webpack://matic/./src/abstracts/base_web3_client.ts","webpack://matic/./src/abstracts/base_contract.ts","webpack://matic/./src/abstracts/base_big_number.ts","webpack://matic/./src/implementation/bn.ts","webpack://matic/./src/utils/converter.ts","webpack://matic/./src/utils/use.ts","webpack://matic/./src/utils/event_bus.ts","webpack://matic/./src/utils/error_helper.ts","webpack://matic/./src/utils/logger.ts","webpack://matic/./src/utils/merge.ts","webpack://matic/./src/utils/map_promise.ts","webpack://matic/./node_modules/@noble/hashes/esm/_assert.js","webpack://matic/./node_modules/@noble/hashes/esm/_u64.js","webpack://matic/./node_modules/@noble/hashes/esm/utils.js","webpack://matic/./node_modules/@noble/hashes/esm/sha3.js","webpack://matic/./node_modules/ethereum-cryptography/esm/utils.js","webpack://matic/./node_modules/ethereum-cryptography/esm/keccak.js","webpack://matic/./src/utils/keccak.ts","webpack://matic/./src/constant.ts","webpack://matic/./src/utils/merkle_tree.ts","webpack://matic/./src/utils/buffer-utils.ts","webpack://matic/./src/utils/proof_util.ts","webpack://matic/./src/utils/http_request.ts","webpack://matic/./src/utils/web3_side_chain_client.ts","webpack://matic/./src/utils/promise_resolve.ts","webpack://matic/./src/utils/base_token.ts","webpack://matic/./src/services/abi_service.ts","webpack://matic/./src/config.ts","webpack://matic/./src/services/network_service.ts","webpack://matic/./src/services/index.ts","webpack://matic/./src/utils/set_proof_api_url.ts","webpack://matic/./src/utils/resolve.ts","webpack://matic/./src/utils/bridge_client.ts","webpack://matic/./src/utils/abi_manager.ts","webpack://matic/./src/utils/not_implemented.ts","webpack://matic/./src/utils/zkevm_bridge_client.ts","webpack://matic/./src/utils/index.ts","webpack://matic/./src/pos/pos_token.ts","webpack://matic/./src/pos/erc20.ts","webpack://matic/./src/pos/root_chain_manager.ts","webpack://matic/./src/pos/exit_util.ts","webpack://matic/./src/pos/root_chain.ts","webpack://matic/./src/pos/erc721.ts","webpack://matic/./src/pos/erc1155.ts","webpack://matic/./src/pos/gas_swapper.ts","webpack://matic/./src/pos/index.ts","webpack://matic/./src/default.ts","webpack://matic/./src/zkevm/zkevm_token.ts","webpack://matic/./src/zkevm/zkevm_custom_bridge.ts","webpack://matic/./src/zkevm/erc20.ts","webpack://matic/./src/zkevm/zkevm_bridge.ts","webpack://matic/./src/zkevm/bridge_util.ts","webpack://matic/./src/zkevm/zkevm_wrapper.ts","webpack://matic/./src/zkevm/index.ts","webpack://matic/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@ethereumjs/util\"), require(\"buffer\"), require(\"bn.js\"), require(\"rlp\"), require(\"@ethereumjs/trie\"), require(\"@ethereumjs/block\"), require(\"@ethereumjs/common\"), require(\"node-fetch\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"matic\", [\"@ethereumjs/util\", \"buffer\", \"bn.js\", \"rlp\", \"@ethereumjs/trie\", \"@ethereumjs/block\", \"@ethereumjs/common\", \"node-fetch\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"matic\"] = factory(require(\"@ethereumjs/util\"), require(\"buffer\"), require(\"bn.js\"), require(\"rlp\"), require(\"@ethereumjs/trie\"), require(\"@ethereumjs/block\"), require(\"@ethereumjs/common\"), require(\"node-fetch\"));\n\telse\n\t\troot[\"matic\"] = factory(root[\"@ethereumjs/util\"], root[\"buffer\"], root[\"bn.js\"], root[\"rlp\"], root[\"@ethereumjs/trie\"], root[\"@ethereumjs/block\"], root[\"@ethereumjs/common\"], root[\"node-fetch\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__335__, __WEBPACK_EXTERNAL_MODULE__18__, __WEBPACK_EXTERNAL_MODULE__773__, __WEBPACK_EXTERNAL_MODULE__514__, __WEBPACK_EXTERNAL_MODULE__935__, __WEBPACK_EXTERNAL_MODULE__804__, __WEBPACK_EXTERNAL_MODULE__858__, __WEBPACK_EXTERNAL_MODULE__849__) => {\nreturn ","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__804__;","module.exports = __WEBPACK_EXTERNAL_MODULE__858__;","module.exports = __WEBPACK_EXTERNAL_MODULE__935__;","module.exports = __WEBPACK_EXTERNAL_MODULE__335__;","module.exports = __WEBPACK_EXTERNAL_MODULE__773__;","module.exports = __WEBPACK_EXTERNAL_MODULE__18__;","module.exports = __WEBPACK_EXTERNAL_MODULE__849__;","module.exports = __WEBPACK_EXTERNAL_MODULE__514__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { ITransactionRequestConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContractMethod {\n    constructor(public logger: Logger) {\n\n    }\n    abstract get address(): string;\n    abstract read<T>(tx?: ITransactionRequestConfig, defaultBlock?: number | string): Promise<T>;\n    abstract write(tx: ITransactionRequestConfig,): ITransactionWriteResult;\n    abstract estimateGas(tx: ITransactionRequestConfig,): Promise<number>;\n    abstract encodeABI(): any;\n}","export enum Log_Event_Signature {\n    // PlasmaErc20WithdrawEventSig = '0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f',\n    // PlasmaErc721WithdrawEventSig = '0x9b1bfa7fa9ee420a16e124f794c35ac9f90472acc99140eb2f6447c714cad8eb',\n    Erc20Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc721Transfer = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef',\n    Erc1155Transfer = '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62',\n    Erc721BatchTransfer = '0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df',\n    Erc1155BatchTransfer = '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb',\n    Erc721TransferWithMetadata = '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14',\n}\n","export enum ERROR_TYPE {\n    AllowedOnRoot = \"allowed_on_root\",\n    AllowedOnChild = \"allowed_on_child\",\n    Unknown = \"unknown\",\n    ProofAPINotSet = \"proof_api_not_set\",\n    TransactionOptionNotObject = \"transation_object_not_object\",\n    BurnTxNotCheckPointed = \"burn_tx_not_checkpointed\",\n    EIP1559NotSupported = \"eip-1559_not_supported\",\n    NullSpenderAddress = \"null_spender_address\",\n    AllowedOnNonNativeTokens = \"allowed_on_non_native_token\",\n    AllowedOnMainnet = \"allowed_on_mainnet\",\n    BridgeAdapterNotFound = \"bridge_adapter_address_not_passed\"\n}\n","import { BaseContract } from \"../abstracts\";\nimport { ITransactionRequestConfig, ITransactionReceipt, ITransactionData, IBlock, IBlockWithTransaction, IJsonRpcRequestPayload, IJsonRpcResponse, ITransactionWriteResult } from \"../interfaces\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseWeb3Client {\n    abstract name: string;\n\n    constructor(public logger: Logger) {\n\n    }\n\n    abstract getContract(address: string, abi: any): BaseContract;\n\n    abstract read(config: ITransactionRequestConfig): Promise<string>;\n\n    abstract write(config: ITransactionRequestConfig): ITransactionWriteResult;\n    abstract getGasPrice(): Promise<string>;\n    abstract estimateGas(config: ITransactionRequestConfig): Promise<number>;\n    abstract getChainId(): Promise<number>;\n    abstract getTransactionCount(address: string, blockNumber: any): Promise<number>;\n\n    abstract getTransaction(transactionHash: string): Promise<ITransactionData>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<ITransactionReceipt>;\n    // abstract extend(property: string, methods: IMethod[])\n\n    abstract getBlock(blockHashOrBlockNumber): Promise<IBlock>;\n    abstract getBlockWithTransaction(blockHashOrBlockNumber): Promise<IBlockWithTransaction>;\n    abstract hexToNumber(value: any): number;\n    abstract hexToNumberString(value: any): string;\n    abstract getBalance(address: string): Promise<string>;\n    abstract getAccounts(): Promise<string[]>;\n    abstract signTypedData(signer: string, typedData: object): Promise<string>;\n\n    async getRootHash?(startBlock: number, endBlock: number) {\n        try {\n            const payload = await this.sendRPCRequest({\n                jsonrpc: '2.0',\n                method: 'bor_getRootHash',\n                params: [Number(startBlock), Number(endBlock)],\n                id: new Date().getTime()\n            });\n            if (payload && payload.result) {\n                return String(payload.result);\n            }\n            throw new Error('No result found for bor_getRootHash');\n        } catch (error) {\n            const payload = await this.sendRPCRequest({\n                jsonrpc: '2.0',\n                method: 'eth_getRootHash',\n                params: [Number(startBlock), Number(endBlock)],\n                id: new Date().getTime()\n            });\n            if (payload && payload.result) {\n                return String(payload.result);\n            }\n            throw new Error('No result found for bor_getRootHash and eth_getRootHash');\n        }\n    }\n\n    getAccountsUsingRPC_() {\n        return this.sendRPCRequest({\n            jsonrpc: '2.0',\n            method: 'eth_accounts',\n            params: [],\n            id: new Date().getTime()\n        }).then(payload => {\n            return payload.result;\n        });\n    }\n\n    abstract sendRPCRequest(request: IJsonRpcRequestPayload): Promise<IJsonRpcResponse>;\n\n    abstract encodeParameters(params: any[], types: any[]): string;\n    abstract decodeParameters(hexString: string, types: any[]): any[];\n    abstract etheriumSha3(...value): string;\n\n}\n","import { BaseContractMethod } from \"../abstracts\";\nimport { Logger } from \"../utils\";\n\nexport abstract class BaseContract {\n\n    constructor(public address: string, public logger:Logger) {\n\n    }\n\n    abstract method(methodName: string, ...args): BaseContractMethod;\n}","import { throwNotImplemented } from \"..\";\n\nexport abstract class BaseBigNumber {\n    static isBN(value) {\n        return throwNotImplemented<boolean>();\n    }\n\n    abstract toString(): string;\n    abstract toNumber(): number;\n    abstract add(value: BaseBigNumber): BaseBigNumber;\n    abstract sub(value: BaseBigNumber): BaseBigNumber;\n    abstract mul(value: BaseBigNumber): BaseBigNumber;\n    abstract div(value: BaseBigNumber): BaseBigNumber;\n\n    abstract lte(value: BaseBigNumber): boolean;\n    abstract lt(value: BaseBigNumber): boolean;\n    abstract gte(value: BaseBigNumber): boolean;\n    abstract gt(value: BaseBigNumber): boolean;\n    abstract eq(value: BaseBigNumber): boolean;\n}\n","import { throwNotImplemented } from \"..\";\nimport { BaseBigNumber } from \"../abstracts\";\n\nexport class EmptyBigNumber extends BaseBigNumber {\n\n    constructor(value) {\n        super();\n    }\n\n    toString(base?) {\n        return throwNotImplemented<string>();\n    }\n\n    toNumber() {\n        return throwNotImplemented<number>();\n    }\n\n    add(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    sub(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    mul(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    div(value: BaseBigNumber) {\n        return throwNotImplemented<BaseBigNumber>();\n    }\n\n    lte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n\n    lt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gte(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    gt(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n\n    }\n\n    eq(value: BaseBigNumber) {\n        return throwNotImplemented<boolean>();\n    }\n}\n","import { BaseBigNumber } from \"../abstracts\";\nimport { utils } from \"../utils\";\n\nexport class Converter {\n    static toHex(amount: BaseBigNumber | string | number) {\n        const dataType = typeof amount;\n        if (dataType === 'number') {\n            amount = new utils.BN(amount);\n        } else if (dataType === 'string') {\n            if ((amount as string).slice(0, 2) === '0x') {\n                return amount;\n            }\n            amount = new utils.BN(amount);\n        }\n        if (utils.BN.isBN(amount)) {\n            return '0x' + amount.toString(16);\n        }\n        else {\n            throw new Error(`Invalid value ${amount}, value is not a number.`);\n        }\n    }\n\n    static toBN(amount: BaseBigNumber | string | number): BaseBigNumber {\n        const dataType = typeof amount;\n        if (dataType === 'string') {\n            if ((amount as string).slice(0, 2) === '0x') {\n                amount = parseInt(amount as string, 16);\n            }\n        }\n        if (!utils.BN.isBN(amount)) {\n            amount = new utils.BN(amount);\n        }\n        return amount as BaseBigNumber;\n    }\n}\n","import { IPlugin } from \"../interfaces\";\nimport { defaultExport } from \"../default\";\n\nexport const use = (plugin, ...payload) => {\n    const pluginInstance: IPlugin = typeof plugin === \"function\" ? new plugin() : plugin;\n    return pluginInstance.setup(defaultExport, ...payload);\n};","export interface IEventBusPromise<T> extends Promise<T> {\n    on(event: string, cb: Function);\n    emit(event: string, ...args);\n    destroy();\n}\n\nexport const eventBusPromise = function <T>(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void) {\n    const promise: IEventBusPromise<T> = new Promise(executor) as any;\n    const eventBus = new EventBus();\n    promise.on = eventBus.on.bind(eventBus);\n    promise.emit = eventBus.emit.bind(eventBus);\n    return promise;\n};\n\nexport class EventBus {\n\n    constructor(ctx?) {\n        this._ctx = ctx;\n    }\n\n    private _ctx;\n\n    private _events: {\n        [key: string]: Function[]\n    } = {};\n\n    on(event: string, cb: Function) {\n        if (this._events[event] == null) {\n            this._events[event] = [];\n        }\n        this._events[event].push(cb);\n        return this;\n    }\n\n    off(event: string, cb: Function) {\n        if (this._events[event]) {\n            if (cb) {\n                const index = this._events[event].indexOf(cb);\n                this._events[event].splice(index, 1);\n            }\n            else {\n                this._events[event] = [];\n            }\n        }\n    }\n\n    emit(event: string, ...args) {\n        const events = this._events[event] || [];\n        return Promise.all(\n            events.map(cb => {\n                const result = cb.call(this._ctx, ...args);\n                return result && result.then ? result : Promise.resolve(result);\n            })\n        );\n    }\n\n    destroy() {\n        this._events = null;\n        this._ctx = null;\n    }\n}","import { ERROR_TYPE } from \"../enums\";\nimport { IError } from \"../interfaces\";\n\nexport class ErrorHelper implements IError {\n    type: ERROR_TYPE;\n    message: string;\n\n    constructor(type: ERROR_TYPE, info?) {\n        this.type = type;\n        this.message = this.getMsg_(info);\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_(info) {\n        let errMsg: string;\n        switch (this.type) {\n            case ERROR_TYPE.AllowedOnChild:\n                errMsg = `The action ${info} is allowed only on child token.`;\n                break;\n            case ERROR_TYPE.AllowedOnRoot:\n                errMsg = `The action ${info} is allowed only on root token.`;\n                break;\n            case ERROR_TYPE.AllowedOnMainnet:\n                errMsg = `The action is allowed only on mainnet chains.`;\n                break;\n            case ERROR_TYPE.ProofAPINotSet:\n                errMsg = `Proof api is not set, please set it using \"setProofApi\"`;\n                break;\n            case ERROR_TYPE.BurnTxNotCheckPointed:\n                errMsg = `Burn transaction has not been checkpointed as yet`;\n                break;\n            case ERROR_TYPE.EIP1559NotSupported:\n                errMsg = `${info ? 'Root' : 'Child'} chain doesn't support eip-1559`;\n                break;\n            case ERROR_TYPE.NullSpenderAddress:\n                errMsg = `Please provide spender address.`;\n                break;\n            default:\n                if (!this.type) {\n                    this.type = ERROR_TYPE.Unknown;\n                }\n                errMsg = this.message;\n                break;\n        }\n        return errMsg;\n    }\n}","import { ERROR_TYPE } from \"../enums\";\nimport { ErrorHelper } from \"./error_helper\";\n\nexport class Logger {\n\n    private isEnabled: boolean;\n\n    enableLog(value) {\n        this.isEnabled = value ? true : false;\n    }\n\n    log(...message) {\n        if (this.isEnabled) {\n            console.log(...message);\n        }\n    }\n\n    error(type: ERROR_TYPE, info?) {\n        return new ErrorHelper(type, info);\n    }\n}","export const merge = (...obj) => {\n    return Object.assign({}, ...obj);\n};","import { promiseResolve } from '..';\nimport { IMapPromiseOption } from '../interfaces';\n\nconst runPromises = (promises: Array<Promise<any>>, converter: Function) => {\n  const maps = promises.map((val, index) => {\n    return converter(val, index);\n  });\n  return Promise.all(maps);\n};\n\nexport function mapPromise(values: any[], converter: Function, option: IMapPromiseOption = {} as any) {\n  const valuesLength = values.length;\n  const concurrency = option.concurrency || valuesLength;\n\n  let result = [];\n  const limitPromiseRun: () => Promise<any> = () => {\n    const promises = values.splice(0, concurrency);\n    return runPromises(promises, converter).then(promiseResult => {\n      result = result.concat(promiseResult);\n\n      return valuesLength > result.length ?\n        limitPromiseRun() : promiseResolve(result);\n    });\n  };\n\n  return limitPromiseRun();\n}\n","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { bytes as abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nexport const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nexport const byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nexport const byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nexport function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, isLE, byteSwap32, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        if (!isLE)\n            byteSwap32(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!isLE)\n            byteSwap32(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","import assert from \"@noble/hashes/_assert\";\nimport { hexToBytes as _hexToBytes } from \"@noble/hashes/utils\";\nconst assertBool = assert.bool;\nconst assertBytes = assert.bytes;\nexport { assertBool, assertBytes };\nexport { bytesToHex, bytesToHex as toHex, concatBytes, createView, utf8ToBytes } from \"@noble/hashes/utils\";\n// buf.toString('utf8') -> bytesToUtf8(buf)\nexport function bytesToUtf8(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);\n    }\n    return new TextDecoder().decode(data);\n}\nexport function hexToBytes(data) {\n    const sliced = data.startsWith(\"0x\") ? data.substring(2) : data;\n    return _hexToBytes(sliced);\n}\n// buf.equals(buf2) -> equalsBytes(buf, buf2)\nexport function equalsBytes(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n// Internal utils\nexport function wrapHash(hash) {\n    return (msg) => {\n        assert.bytes(msg);\n        return hash(msg);\n    };\n}\n// TODO(v3): switch away from node crypto, remove this unnecessary variable.\nexport const crypto = (() => {\n    const webCrypto = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : undefined;\n    const nodeRequire = typeof module !== \"undefined\" &&\n        typeof module.require === \"function\" &&\n        module.require.bind(module);\n    return {\n        node: nodeRequire && !webCrypto ? nodeRequire(\"crypto\") : undefined,\n        web: webCrypto\n    };\n})();\n","import { keccak_224, keccak_256, keccak_384, keccak_512 } from \"@noble/hashes/sha3\";\nimport { wrapHash } from \"./utils.js\";\nexport const keccak224 = wrapHash(keccak_224);\nexport const keccak256 = (() => {\n    const k = wrapHash(keccak_256);\n    k.create = keccak_256.create;\n    return k;\n})();\nexport const keccak384 = wrapHash(keccak_384);\nexport const keccak512 = wrapHash(keccak_512);\n","import { keccak224, keccak384, keccak256 as k256, keccak512 } from 'ethereum-cryptography/keccak';\n\nexport class Keccak {\n    /**\n     * Throws if input is not a buffer\n     * @param {Buffer} input value to check\n     */\n    static assertIsBuffer = function (input: Buffer): void {\n        if (!Buffer.isBuffer(input)) {\n        const msg = `This method only supports Buffer but input was: ${input}`;\n        throw new Error(msg);\n        }\n    };\n\n    /**\n     * Creates Keccak hash of a Buffer input\n     * @param a The input data (Buffer)\n     * @param bits (number = 256) The Keccak width\n     */\n    static keccak = function (a: Buffer, bits = 256): Buffer {\n        Keccak.assertIsBuffer(a);\n        switch (bits) {\n            case 224: {\n                return Buffer.from(keccak224(a));\n            }\n            case 256: {\n                return Buffer.from(k256(a));\n            }\n            case 384: {\n                return Buffer.from(keccak384(a));\n            }\n            case 512: {\n                return Buffer.from(keccak512(a));\n            }\n            default: {\n                throw new Error(`Invald algorithm: keccak${bits}`);\n            }\n        }\n    };\n\n    /**\n     * Creates Keccak-256 hash of the input, alias for keccak(a, 256).\n     * @param a The input data (Buffer)\n     */\n    static keccak256 = function (a: Buffer): Buffer {\n        return Keccak.keccak(a);\n    };\n}\n","export const MAX_AMOUNT = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';\nexport const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';\nexport const DAI_PERMIT_TYPEHASH = \"0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb\";\nexport const EIP_2612_PERMIT_TYPEHASH = \"0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9\";\nexport const EIP_2612_DOMAIN_TYPEHASH = \"0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f\";\nexport const UNISWAP_DOMAIN_TYPEHASH = \"0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866\";\nexport const _GLOBAL_INDEX_MAINNET_FLAG = BigInt(2 ** 64);\nexport enum Permit {\n    DAI = \"DAI\",\n    EIP_2612 = \"EIP_2612\",\n    UNISWAP = \"UNISWAP\",\n}\n","import { zeros } from '@ethereumjs/util';\nimport { Keccak } from './keccak';\nconst sha3 = Keccak.keccak256;\n\nimport { Buffer as SafeBuffer } from \"safe-buffer\";\n\nexport class MerkleTree {\n    leaves: any;\n    layers: any;\n\n    constructor(leaves = []) {\n        if (leaves.length < 1) {\n            throw new Error('Atleast 1 leaf needed');\n        }\n\n        const depth = Math.ceil(Math.log(leaves.length) / Math.log(2));\n        if (depth > 20) {\n            throw new Error('Depth must be 20 or less');\n        }\n\n        this.leaves = leaves.concat(\n            Array.from(\n                // tslint:disable-next-line\n                Array(Math.pow(2, depth) - leaves.length),\n                () => zeros(32)\n            )\n        );\n        this.layers = [this.leaves];\n        this.createHashes(this.leaves);\n    }\n\n    createHashes(nodes) {\n        if (nodes.length === 1) {\n            return false;\n        }\n\n\n        const treeLevel = [];\n        for (let i = 0; i < nodes.length; i += 2) {\n            const left = nodes[i];\n            const right = nodes[i + 1];\n\n            const data = SafeBuffer.concat([left, right]);\n            treeLevel.push(sha3(data as unknown as Buffer));\n        }\n\n        // is odd number of nodes\n        if (nodes.length % 2 === 1) {\n            treeLevel.push(nodes[nodes.length - 1]);\n        }\n\n        this.layers.push(treeLevel);\n        this.createHashes(treeLevel);\n    }\n\n    getLeaves() {\n        return this.leaves;\n    }\n\n    getLayers() {\n        return this.layers;\n    }\n\n    getRoot() {\n        return this.layers[this.layers.length - 1][0];\n    }\n\n    getProof(leaf) {\n        let index = -1;\n        for (let i = 0; i < this.leaves.length; i++) {\n            if (SafeBuffer.compare(leaf, this.leaves[i]) === 0) {\n                index = i;\n            }\n        }\n\n        const proof = [];\n        if (index <= this.getLeaves().length) {\n            let siblingIndex;\n            for (let i = 0; i < this.layers.length - 1; i++) {\n                if (index % 2 === 0) {\n                    siblingIndex = index + 1;\n                } else {\n                    siblingIndex = index - 1;\n                }\n                index = Math.floor(index / 2);\n                proof.push(this.layers[i][siblingIndex]);\n            }\n        }\n        return proof;\n    }\n\n    verify(value, index, root, proof) {\n        if (!Array.isArray(proof) || !value || !root) {\n            return false;\n        }\n\n        let hash = value;\n        for (let i = 0; i < proof.length; i++) {\n            const node = proof[i];\n            if (index % 2 === 0) {\n                hash = sha3(SafeBuffer.concat([hash, node]) as unknown as Buffer);\n            } else {\n                hash = sha3(SafeBuffer.concat([node, hash]) as unknown as Buffer);\n            }\n\n            index = Math.floor(index / 2);\n        }\n\n        return SafeBuffer.compare(hash, root) === 0;\n    }\n}\n","import {\n    ITransformableToArray,\n    PrefixedHexString,\n    ITransformableToBuffer,\n    BN\n} from \"./types\";\n\nexport type ToBufferInputTypes =\n    | PrefixedHexString\n    | number\n    | BN\n    | Buffer\n    | Uint8Array\n    | number[]\n    | ITransformableToArray\n    | ITransformableToBuffer\n    | null\n    | undefined;\n\nexport class BufferUtil {\n    static intToHex = function (i: number) {\n        if (!Number.isSafeInteger(i) || i < 0) {\n            throw new Error(`Received an invalid integer type: ${i}`);\n        }\n        return `0x${i.toString(16)}`;\n    };\n\n    static padToEven(value: string): string {\n        let a = value;\n\n        if (typeof a !== 'string') {\n            throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);\n        }\n\n        if (a.length % 2) a = `0${a}`;\n\n        return a;\n    }\n\n    static isHexPrefixed(str: string): boolean {\n        if (typeof str !== 'string') {\n            throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n        }\n\n        return str[0] === '0' && str[1] === 'x';\n    }\n\n    static stripHexPrefix = (str: string): string => {\n        if (typeof str !== 'string') {\n            throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);\n        }\n\n        return BufferUtil.isHexPrefixed(str) ? str.slice(2) : str;\n    }\n\n    /**\n     * Converts an `Number` to a `Buffer`\n     * @param {Number} i\n     * @return {Buffer}\n     */\n    static intToBuffer = function (i: number) {\n        const hex = BufferUtil.intToHex(i);\n        return Buffer.from(BufferUtil.padToEven(hex.slice(2)), 'hex');\n    };\n\n    static isHexString(value: string, length?: number): boolean {\n        if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n\n        if (length && value.length !== 2 + 2 * length) return false;\n\n        return true;\n    }\n\n\n    static toBuffer = function (v: ToBufferInputTypes): Buffer {\n        if (v === null || v === undefined) {\n            return Buffer.allocUnsafe(0);\n        }\n\n        if (Buffer.isBuffer(v)) {\n            return Buffer.from(v);\n        }\n\n        if (Array.isArray(v) || v instanceof Uint8Array) {\n            return Buffer.from(v as Uint8Array);\n        }\n\n        if (typeof v === 'string') {\n            if (!BufferUtil.isHexString(v)) {\n                throw new Error(\n                    `Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`\n                );\n            }\n            return Buffer.from(BufferUtil.padToEven(BufferUtil.stripHexPrefix(v)), 'hex');\n        }\n\n        if (typeof v === 'number') {\n            return BufferUtil.intToBuffer(v);\n        }\n\n        if (BN.isBN(v)) {\n            if (v.isNeg()) {\n                throw new Error(`Cannot convert negative BN to buffer. Given: ${v}`);\n            }\n            return v.toArrayLike(Buffer);\n        }\n\n        if (v.toArray) {\n            // converts a BN to a Buffer\n            return Buffer.from(v.toArray());\n        }\n\n        if (v.toBuffer) {\n            return Buffer.from(v.toBuffer());\n        }\n\n        throw new Error('invalid type');\n    };\n\n    /**\n     * Converts a `Buffer` into a `0x`-prefixed hex `String`.\n     * @param buf `Buffer` object to convert\n     */\n    static bufferToHex = function (buf: Buffer): string {\n        buf = BufferUtil.toBuffer(buf);\n        return '0x' + buf.toString('hex');\n    };\n}\n","import { BaseWeb3Client } from \"../abstracts\";\nimport { MerkleTree } from \"./merkle_tree\";\nimport { setLengthLeft } from \"@ethereumjs/util\";\nimport { Keccak } from \"./keccak\";\nimport { BufferUtil } from \"./buffer-utils\";\nimport rlp from \"rlp\";\nimport { ITransactionReceipt, IBlock, IBlockWithTransaction } from \"../interfaces\";\nimport { mapPromise } from \"./map_promise\";\nimport { Trie as TRIE } from '@ethereumjs/trie';\nimport { BlockHeader } from '@ethereumjs/block';\nimport { Converter, promiseResolve, utils } from \"..\";\nimport { Common, Chain, Hardfork } from '@ethereumjs/common';\n\n// Implementation adapted from Tom French's `matic-proofs` library used under MIT License\n// https://github.com/TomAFrench/matic-proofs\n\nexport class ProofUtil {\n\n    static async getFastMerkleProof(\n        web3: BaseWeb3Client,\n        blockNumber: number,\n        startBlock: number,\n        endBlock: number\n    ): Promise<string[]> {\n        const merkleTreeDepth = Math.ceil(Math.log2(endBlock - startBlock + 1));\n\n        // We generate the proof root down, whereas we need from leaf up\n        const reversedProof: string[] = [];\n\n        const offset = startBlock;\n        const targetIndex = blockNumber - offset;\n        let leftBound = 0;\n        let rightBound = endBlock - offset;\n        //   console.log(\"Searching for\", targetIndex);\n        for (let depth = 0; depth < merkleTreeDepth; depth += 1) {\n            const nLeaves = 2 ** (merkleTreeDepth - depth);\n\n            // The pivot leaf is the last leaf which is included in the left subtree\n            const pivotLeaf = leftBound + nLeaves / 2 - 1;\n\n            if (targetIndex > pivotLeaf) {\n                // Get the root hash to the merkle subtree to the left\n                const newLeftBound = pivotLeaf + 1;\n                // eslint-disable-next-line no-await-in-loop\n                const subTreeMerkleRoot = await this.queryRootHash(web3, offset + leftBound, offset + pivotLeaf);\n                reversedProof.push(subTreeMerkleRoot);\n                leftBound = newLeftBound;\n            } else {\n                // Things are more complex when querying to the right.\n                // Root hash may come some layers down so we need to build a full tree by padding with zeros\n                // Some trees may be completely empty\n\n                const newRightBound = Math.min(rightBound, pivotLeaf);\n\n                // Expect the merkle tree to have a height one less than the current layer\n                const expectedHeight = merkleTreeDepth - (depth + 1);\n                if (rightBound <= pivotLeaf) {\n                    // Tree is empty so we repeatedly hash zero to correct height\n                    const subTreeMerkleRoot = this.recursiveZeroHash(expectedHeight, web3);\n                    reversedProof.push(subTreeMerkleRoot);\n                } else {\n                    // Height of tree given by RPC node\n                    const subTreeHeight = Math.ceil(Math.log2(rightBound - pivotLeaf));\n\n                    // Find the difference in height between this and the subtree we want\n                    const heightDifference = expectedHeight - subTreeHeight;\n\n                    // For every extra layer we need to fill 2*n leaves filled with the merkle root of a zero-filled Merkle tree\n                    // We need to build a tree which has heightDifference layers\n\n                    // The first leaf will hold the root hash as returned by the RPC\n                    // eslint-disable-next-line no-await-in-loop\n                    const remainingNodesHash = await this.queryRootHash(web3, offset + pivotLeaf + 1, offset + rightBound);\n\n                    // The remaining leaves will hold the merkle root of a zero-filled tree of height subTreeHeight\n                    const leafRoots = this.recursiveZeroHash(subTreeHeight, web3);\n\n                    // Build a merkle tree of correct size for the subtree using these merkle roots\n                    const leaves = Array.from({ length: 2 ** heightDifference }, () => BufferUtil.toBuffer(leafRoots));\n                    leaves[0] = remainingNodesHash;\n                    const subTreeMerkleRoot = new MerkleTree(leaves).getRoot();\n                    reversedProof.push(subTreeMerkleRoot);\n                }\n                rightBound = newRightBound;\n            }\n        }\n\n        return reversedProof.reverse();\n    }\n\n    static buildBlockProof(maticWeb3: BaseWeb3Client, startBlock: number, endBlock: number, blockNumber: number) {\n        return ProofUtil.getFastMerkleProof(\n            maticWeb3, blockNumber, startBlock, endBlock\n        ).then(proof => {\n            return BufferUtil.bufferToHex(\n                Buffer.concat(\n                    proof.map(p => {\n                        return BufferUtil.toBuffer(p);\n                    })\n                )\n            );\n        });\n    }\n\n    static queryRootHash(client: BaseWeb3Client, startBlock: number, endBlock: number) {\n        return client.getRootHash(startBlock, endBlock).then(rootHash => {\n            return BufferUtil.toBuffer(`0x${rootHash}`);\n        }).catch(_ => {\n            return null;\n        });\n    }\n\n    static recursiveZeroHash(n: number, client: BaseWeb3Client) {\n        if (n === 0) return '0x0000000000000000000000000000000000000000000000000000000000000000';\n        const subHash = this.recursiveZeroHash(n - 1, client);\n        return Keccak.keccak256(\n            BufferUtil.toBuffer(client.encodeParameters([subHash, subHash], ['bytes32', 'bytes32'],))\n        );\n    }\n\n    static getReceiptProof(receipt: ITransactionReceipt, block: IBlockWithTransaction, web3: BaseWeb3Client, requestConcurrency = Infinity, receiptsVal?: ITransactionReceipt[]) {\n        const stateSyncTxHash = BufferUtil.bufferToHex(ProofUtil.getStateSyncTxHash(block));\n        const receiptsTrie = new TRIE();\n        let receiptPromise: Promise<ITransactionReceipt[]>;\n        if (!receiptsVal) {\n            const receiptPromises = [];\n            block.transactions.forEach(tx => {\n                if (tx.transactionHash === stateSyncTxHash) {\n                    // ignore if tx hash is bor state-sync tx\n                    return;\n                }\n                receiptPromises.push(\n                    web3.getTransactionReceipt(tx.transactionHash)\n                );\n            });\n            receiptPromise = mapPromise(\n                receiptPromises,\n                val => {\n                    return val;\n                },\n                {\n                    concurrency: requestConcurrency,\n                }\n            );\n        }\n        else {\n            receiptPromise = promiseResolve(receiptsVal);\n        }\n\n        return receiptPromise.then(receipts => {\n            return Promise.all(\n                receipts.map(siblingReceipt => {\n                    const path = rlp.encode(siblingReceipt.transactionIndex);\n                    const rawReceipt = ProofUtil.getReceiptBytes(siblingReceipt);\n                    return receiptsTrie.put(path, rawReceipt);\n                })\n            );\n        }).then(_ => {\n            return receiptsTrie.findPath(rlp.encode(receipt.transactionIndex), true);\n        }).then(result => {\n            if (result.remaining.length > 0) {\n                throw new Error('Node does not contain the key');\n            }\n            // result.node.value\n            const getPrfValue = (receipt) => {\n                if (ProofUtil.isTypedReceipt(receipt)) {\n                    return result.node.value;\n                }\n                try {\n                    return rlp.decode(result.node.value.toString());\n                } catch (e) {\n                    return rlp.decode(result.node.value());\n                }\n            };\n            const prf = {\n                blockHash: BufferUtil.toBuffer(receipt.blockHash),\n                parentNodes: result.stack.map(s => s.raw()),\n                root: ProofUtil.getRawHeader(block).receiptTrie,\n                path: rlp.encode(receipt.transactionIndex),\n                value: getPrfValue(receipt)\n            };\n            return prf;\n        });\n    }\n\n    static isTypedReceipt(receipt: ITransactionReceipt) {\n        const hexType = Converter.toHex(receipt.type);\n        return receipt.status != null && hexType !== \"0x0\" && hexType !== \"0x\";\n    }\n\n    // getStateSyncTxHash returns block's tx hash for state-sync receipt\n    // Bor blockchain includes extra receipt/tx for state-sync logs,\n    // but it is not included in transactionRoot or receiptRoot.\n    // So, while calculating proof, we have to exclude them.\n    //\n    // This is derived from block's hash and number\n    // state-sync tx hash = keccak256(\"matic-bor-receipt-\" + block.number + block.hash)\n    static getStateSyncTxHash(block): Buffer {\n        return Keccak.keccak256(\n            Buffer.concat([\n                // prefix for bor receipt\n                Buffer.from('matic-bor-receipt-', 'utf-8'),\n                setLengthLeft(BufferUtil.toBuffer(block.number), 8), // 8 bytes of block number (BigEndian)\n                BufferUtil.toBuffer(block.hash), // block hash\n            ])\n        );\n    }\n\n    static getReceiptBytes(receipt: ITransactionReceipt) {\n        let encodedData = rlp.encode([\n            BufferUtil.toBuffer(\n                receipt.status !== undefined && receipt.status != null ? (receipt.status ? '0x1' : '0x') : receipt.root\n            ),\n            BufferUtil.toBuffer(receipt.cumulativeGasUsed),\n            BufferUtil.toBuffer(receipt.logsBloom),\n            // encoded log array\n            receipt.logs.map(l => {\n                // [address, [topics array], data]\n                return [\n                    BufferUtil.toBuffer(l.address), // convert address to buffer\n                    l.topics.map(BufferUtil.toBuffer), // convert topics to buffer\n                    BufferUtil.toBuffer(l.data), // convert data to buffer\n                ];\n            }),\n        ]);\n        if (ProofUtil.isTypedReceipt(receipt)) {\n            encodedData = Buffer.concat([BufferUtil.toBuffer(receipt.type), encodedData]);\n        }\n        return encodedData;\n    }\n\n    static getRawHeader(_block) {\n        _block.difficulty = Converter.toHex(_block.difficulty) as any;\n        const common = new Common({\n            chain: Chain.Mainnet, hardfork: Hardfork.London\n        });\n        const rawHeader = BlockHeader.fromHeaderData(_block, {\n            common: common,\n            skipConsensusFormatValidation: true\n        });\n        return rawHeader;\n    }\n}\n","const fetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n    (() => {\n        if (process.env.BUILD_ENV === \"node\") {\n            return require('node-fetch').default;\n        }\n        return window.fetch;\n    })();\n\n\nexport class HttpRequest {\n    baseUrl = \"\";\n\n    constructor(option: { baseUrl: string } | string = {} as any) {\n        option = typeof option === \"string\" ? {\n            baseUrl: option\n        } : option;\n\n        if (option.baseUrl) {\n            this.baseUrl = option.baseUrl;\n        }\n    }\n\n    get<T>(url = \"\", query = {}): Promise<T> {\n        url = this.baseUrl + url + Object.keys(query).\n            map(key => `${encodeURIComponent(key)}=${encodeURIComponent(query[key])}`).join('&');\n\n        return fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            }\n        }).then(res => {\n            return res.json();\n        });\n    }\n\n    post(url = \"\", body) {\n        url = this.baseUrl + url;\n\n        return fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            },\n            body: body ? JSON.stringify(body) : null\n        }).then(res => {\n            return res.json();\n        });\n    }\n}","import { IBaseClientConfig } from \"../interfaces\";\nimport { BaseWeb3Client } from \"../abstracts\";\nimport { ABIManager } from \"../utils\";\nimport { Logger } from \"./logger\";\nimport { utils } from \"..\";\n\nconst chainIdToConfigPath = {\n    1: 'Main',\n    5: 'Main',\n    11155111: 'Main',\n    137: 'Matic',\n    80001: 'Matic',\n    80002: 'Matic',\n    1442: 'zkEVM',\n    2442: 'zkEVM',\n    1101: 'zkEVM'\n};\n\nexport class Web3SideChainClient<T_CONFIG> {\n    parent: BaseWeb3Client;\n    child: BaseWeb3Client;\n\n    config: T_CONFIG;\n\n    abiManager: ABIManager;\n\n    logger = new Logger();\n    resolution: {};\n\n    init(config: IBaseClientConfig) {\n        config = config || {} as any;\n        config.parent.defaultConfig = config.parent.defaultConfig || {} as any;\n        config.child.defaultConfig = config.child.defaultConfig || {} as any;\n        this.config = config as any;\n\n        // tslint:disable-next-line\n        const Web3Client = utils.Web3Client;\n\n        if (!Web3Client) {\n            throw new Error(\"Web3Client is not set\");\n        }\n\n        if (utils.UnstoppableDomains) {\n            this.resolution = utils.UnstoppableDomains;\n        }\n\n        this.parent = new (Web3Client as any)(config.parent.provider, this.logger);\n        this.child = new (Web3Client as any)(config.child.provider, this.logger);\n\n        this.logger.enableLog(config.log);\n\n        const network = config.network;\n        const version = config.version;\n        const abiManager = this.abiManager =\n            new ABIManager(network, version);\n        this.logger.log(\"init called\", abiManager);\n        return abiManager.init().catch(err => {\n            throw new Error(`network ${network} - ${version} is not supported`);\n        });\n    }\n\n    getABI(name: string, type?: string) {\n        return this.abiManager.getABI(name, type);\n    }\n\n    getConfig(path: string) {\n        return this.abiManager.getConfig(path);\n    }\n\n    get mainPlasmaContracts() {\n        return this.getConfig(\"Main.Contracts\");\n    }\n\n    get mainPOSContracts() {\n        return this.getConfig(\"Main.POSContracts\");\n    }\n\n    get mainZkEvmContracts() {\n        return this.getConfig(\"Main.Contracts\");\n    }\n\n    get zkEvmContracts() {\n        return this.getConfig(\"zkEVM.Contracts\");\n    }\n\n    isEIP1559Supported(chainId: number): boolean {\n        return this.getConfig(`${chainIdToConfigPath[chainId]}.SupportsEIP1559`);\n    }\n\n}\n","export const promiseResolve = <T>(value?) => {\n    return Promise.resolve<T>(value);\n};\n\nexport const promiseAny = (promisesArray) => {\n    const promiseErrors = new Array(promisesArray.length);\n    let counter = 0;\n\n    //return a new promise\n    return new Promise((resolve, reject) => {\n        promisesArray.forEach((promise) => {\n            Promise.resolve(promise)\n                .then(resolve) // resolve, when any of the input promise resolves\n                .catch((error) => {\n                    promiseErrors[counter] = error;\n                    counter = counter + 1;\n                    if (counter === promisesArray.length) {\n                        // all promises rejected, reject outer promise\n                        reject(promiseErrors);\n                    }\n                }); // reject, when any of the input promise rejects\n        });\n    });\n};\n","import { Web3SideChainClient } from \"./web3_side_chain_client\";\nimport { ITransactionRequestConfig, ITransactionOption, IContractInitParam, IBaseClientConfig, ITransactionWriteResult } from \"../interfaces\";\nimport { BaseContractMethod, BaseContract } from \"../abstracts\";\nimport { Converter, merge, utils } from \"../utils\";\nimport { promiseResolve } from \"./promise_resolve\";\nimport { ERROR_TYPE } from \"../enums\";\nimport { POSERC1155TransferParam, TYPE_AMOUNT } from \"../types\";\nimport { ErrorHelper } from \"./error_helper\";\nimport { ADDRESS_ZERO } from '../constant';\n\nexport interface ITransactionConfigParam {\n    txConfig: ITransactionRequestConfig;\n    method?: BaseContractMethod;\n    isWrite?: boolean;\n    isParent?: boolean;\n}\n\nexport class BaseToken<T_CLIENT_CONFIG> {\n\n    private contract_: BaseContract;\n    private chainId_: number;\n\n    constructor(\n        protected contractParam: IContractInitParam,\n        protected client: Web3SideChainClient<T_CLIENT_CONFIG>,\n    ) {\n    }\n\n    get contractAddress() {\n        return this.contractParam.address;\n    }\n\n    getContract(): Promise<BaseContract> {\n        if (this.contract_) {\n            return promiseResolve<BaseContract>(this.contract_ as any);\n        }\n        const contractParam = this.contractParam;\n        return this.client.getABI(\n            contractParam.name,\n            contractParam.bridgeType,\n        ).then(abi => {\n            this.contract_ = this.getContract_({\n                abi,\n                isParent: contractParam.isParent,\n                tokenAddress: contractParam.address\n            });\n            return this.contract_;\n        });\n    }\n\n    getChainId(): Promise<number> {\n        if (this.chainId_) {\n            return promiseResolve<number>(this.chainId_ as any);\n        }\n        const client = this.getClient(this.contractParam.isParent);\n        return client.getChainId().then(chainId => {\n            this.chainId_ = chainId;\n            return this.chainId_;\n        });\n    }\n\n    protected processWrite(method: BaseContractMethod, option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        this.client.logger.log(\"process write\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: method.address\n                    } as ITransactionRequestConfig);\n                }\n                const methodResult = method.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected sendTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process write\");\n\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"process write config\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                const methodResult = client.write(\n                    config,\n                );\n                return methodResult;\n            });\n    }\n\n    protected readTransaction(option: ITransactionOption = {}): Promise<ITransactionWriteResult> {\n        this.validateTxOption_(option);\n        const isParent = this.contractParam.isParent;\n        const client = this.getClient(isParent);\n        client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: true,\n                method: null as any,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                client.logger.log(\"write tx config created\");\n                if (option.returnTransaction) {\n                    return config as any;\n                }\n                return client.read(\n                    config,\n                );\n            });\n    }\n\n    private validateTxOption_(option: ITransactionOption) {\n        if (typeof option !== 'object' || Array.isArray(option)) {\n            new ErrorHelper(ERROR_TYPE.TransactionOptionNotObject).throw();\n        }\n    }\n\n    protected processRead<T>(method: BaseContractMethod, option: ITransactionOption = {}): Promise<T> {\n        this.validateTxOption_(option);\n        this.client.logger.log(\"process read\");\n        return this.createTransactionConfig(\n            {\n                txConfig: option,\n                isWrite: false,\n                method,\n                isParent: this.contractParam.isParent\n            }).then(config => {\n                this.client.logger.log(\"read tx config created\");\n                if (option.returnTransaction) {\n                    return merge(config, {\n                        data: method.encodeABI(),\n                        to: this.contract_.address\n                    } as ITransactionRequestConfig);\n                }\n                return method.read(\n                    config,\n                );\n            });\n    }\n\n    protected getClient(isParent) {\n        return isParent ? this.client.parent :\n            this.client.child;\n    }\n\n    private getContract_({ isParent, tokenAddress, abi }) {\n        const client = this.getClient(isParent);\n        return client.getContract(tokenAddress, abi);\n    }\n\n    protected get parentDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.parent.defaultConfig;\n    }\n\n    protected get childDefaultConfig() {\n        const config: IBaseClientConfig = this.client.config as any;\n        return config.child.defaultConfig;\n    }\n\n    protected createTransactionConfig({ txConfig, method, isParent, isWrite }: ITransactionConfigParam) {\n        const defaultConfig = isParent ? this.parentDefaultConfig : this.childDefaultConfig;\n        txConfig = merge(defaultConfig, (txConfig || {}));\n        const client = isParent ? this.client.parent :\n            this.client.child;\n        client.logger.log(\"txConfig\", txConfig, \"onRoot\", isParent, \"isWrite\", isWrite);\n        const estimateGas = async (config: ITransactionRequestConfig) => {\n            const result = method ? await method.estimateGas(config) : await client.estimateGas(config);\n            return new utils.BN(Math.trunc(Number(result) * 1.15)).toString();\n        };\n        // txConfig.chainId = Converter.toHex(txConfig.chainId) as any;\n        if (isWrite) {\n            return this.getChainId().then(clientChainId => {\n                const { maxFeePerGas, maxPriorityFeePerGas } = txConfig;\n\n                const isEIP1559Supported = this.client.isEIP1559Supported(clientChainId);\n                const isMaxFeeProvided = (maxFeePerGas || maxPriorityFeePerGas);\n                txConfig.chainId = txConfig.chainId || clientChainId;\n\n                if (!isEIP1559Supported && isMaxFeeProvided) {\n                    client.logger.error(ERROR_TYPE.EIP1559NotSupported, isParent).throw();\n                }\n                // const [gasLimit, nonce] = \n                return Promise.all([\n                    !(txConfig.gasLimit)\n                        ? estimateGas({\n                            from: txConfig.from, value: txConfig.value, to: txConfig.to\n                        })\n                        : txConfig.gasLimit,\n                    !txConfig.nonce ?\n                        client.getTransactionCount(txConfig.from, 'pending')\n                        : txConfig.nonce\n                ]).then(result => {\n                    const [gasLimit, nonce] = result;\n                    client.logger.log(\"options filled\");\n\n                    txConfig.gasLimit = Number(gasLimit);\n                    txConfig.nonce = nonce;\n                    return txConfig;\n                });\n            });\n        }\n        return promiseResolve<ITransactionRequestConfig>(txConfig);\n    }\n\n    protected transferERC20(to: string, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transfer\",\n                to,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected transferERC721(from: string, to: string, tokenId: string, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"transferFrom\",\n                from,\n                to,\n                tokenId\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n    protected checkForNonNative(methodName) {\n        if (this.contractParam.address === ADDRESS_ZERO) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnNonNativeTokens, methodName).throw();\n        }\n    }\n\n    protected checkForRoot(methodName) {\n        if (!this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnRoot, methodName).throw();\n        }\n    }\n\n    protected checkForChild(methodName) {\n        if (this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.AllowedOnChild, methodName).throw();\n        }\n    }\n\n    protected checkAdapterPresent(methodName) {\n        if (!this.contractParam.bridgeAdapterAddress) {\n            this.client.logger.error(ERROR_TYPE.BridgeAdapterNotFound, methodName).throw();\n        }\n    }\n\n    protected transferERC1155(param: POSERC1155TransferParam, option: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"safeTransferFrom\",\n                param.from,\n                param.to,\n                Converter.toHex(param.tokenId),\n                Converter.toHex(param.amount),\n                param.data || '0x'\n            );\n            return this.processWrite(\n                method, option\n            );\n        });\n    }\n\n}\n","import { HttpRequest } from \"../utils\";\n\nexport class ABIService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    getABI(network: string, version: string, bridgeType: string, contractName: string) {\n        const url = `${network}/${version}/artifacts/${bridgeType}/${contractName}.json`;\n        return this.httpRequest.get(url).then((result: any) => {\n            return result.abi;\n        });\n    }\n\n    getAddress(network: string, version: string) {\n        const url = `${network}/${version}/index.json`;\n        return this.httpRequest.get(url);\n    }\n}\n","export const config = {\n  abiStoreUrl: 'https://static.polygon.technology/network/',\n  zkEvmBridgeService: 'https://proof-generator.polygon.technology/',\n}\n","import { BaseBigNumber, utils } from \"..\";\nimport { HttpRequest } from \"../utils\";\n\nexport class NetworkService {\n    httpRequest: HttpRequest;\n\n    constructor(baseUrl: string) {\n        this.httpRequest = new HttpRequest(baseUrl);\n    }\n\n    private createUrlForPos(version: string, url: string) {\n        return `${version === 'v1' ? 'matic' : version}${url}`;\n    }\n\n    private createUrlForZkEvm(version: string, url: string) {\n        return `${version}/${url}`;\n    }\n\n    getBlockIncluded(version: string, blockNumber: number) {\n        const url = this.createUrlForPos(version, `/block-included/${blockNumber}`);\n        return this.httpRequest.get<{\n            start: string;\n            end: string;\n            headerBlockNumber: BaseBigNumber;\n        }>(url).then(result => {\n            const headerBlockNumber = result.headerBlockNumber as any as string;\n            const decimalHeaderBlockNumber = headerBlockNumber.slice(0, 2) === '0x' ? parseInt(\n                headerBlockNumber, 16\n            ) : headerBlockNumber;\n            result.headerBlockNumber = new utils.BN(decimalHeaderBlockNumber);\n            return result;\n        });\n    }\n\n    getExitProof(version: string, burnTxHash: string, eventSignature: string) {\n        const url = this.createUrlForPos(version, `/exit-payload/${burnTxHash}?eventSignature=${eventSignature}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.result;\n        });\n    }\n\n    getProof(version: string, start, end, blockNumber) {\n        const url = this.createUrlForPos(version, `/fast-merkle-proof?start=${start}&end=${end}&number=${blockNumber}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.proof;\n        });\n    }\n\n    getMerkleProofForZkEvm(version: string, networkID: number, depositCount: number) {\n        const url = this.createUrlForZkEvm(version, `merkle-proof?net_id=${networkID}&deposit_cnt=${depositCount}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.proof;\n        });\n    }\n\n    getBridgeTransactionDetails(version: string, networkID: number, depositCount: number) {\n        const url = this.createUrlForZkEvm(version, `bridge?net_id=${networkID}&deposit_cnt=${depositCount}`);\n        return this.httpRequest.get<any>(url).then(result => {\n            return result.deposit;\n        });\n    }\n}\n","import { ABIService } from \"./abi_service\";\nimport { config } from \"../config\";\nimport { NetworkService } from \"./network_service\";\n\nexport * from \"./network_service\";\n\nclass Service {\n    network: NetworkService;\n    zkEvmNetwork: NetworkService;\n    abi: ABIService;\n}\n\nexport const service = new Service();\nservice.abi = new ABIService(config.abiStoreUrl);\n\n\n\n","import { service, NetworkService } from \"../services\";\n\nexport const setProofApi = (url: string) => {\n    const urlLength = url.length;\n    if (url[urlLength - 1] !== '/') {\n        url += '/';\n    }\n    url += 'api/v1/';\n    service.network = new NetworkService(url);\n};\n\nexport const setZkEvmProofApi = (url: string) => {\n    const urlLength = url.length;\n    if (url[urlLength - 1] !== '/') {\n        url += '/';\n    }\n    url += 'api/zkevm/';\n    service.zkEvmNetwork = new NetworkService(url);\n};\n","export function resolve(obj, path) {\n    const properties = Array.isArray(path) ? path : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], obj);\n}","import { Web3SideChainClient } from \"../utils\";\nimport { ExitUtil } from \"../pos\";\nimport { BaseToken, utils } from \"..\";\n\nexport class BridgeClient<T> {\n\n    client: Web3SideChainClient<T> = new Web3SideChainClient();\n\n    exitUtil: ExitUtil;\n\n    /**\n     * check whether a txHash is checkPointed \n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof BridgeClient\n     */\n    isCheckPointed(txHash: string) {\n        return this.exitUtil.isCheckPointed(\n            txHash\n        );\n    }\n\n    isDeposited(depositTxHash: string) {\n        const client = this.client;\n\n        const token = new BaseToken({\n            address: client.abiManager.getConfig(\"Matic.GenesisContracts.StateReceiver\"),\n            isParent: false,\n            name: 'StateReceiver',\n            bridgeType: 'genesis'\n        }, client);\n\n        return token.getContract().then(contract => {\n            return Promise.all([\n                client.parent.getTransactionReceipt(depositTxHash),\n                token['processRead']<string>(\n                    contract.method(\"lastStateId\")\n                )\n            ]);\n        }).then(result => {\n            const [receipt, lastStateId] = result;\n            const eventSignature = `0x103fed9db65eac19c4d870f49ab7520fe03b99f1838e5996caf47e9e43308392`;\n            const targetLog = receipt.logs.find(q => q.topics[0] === eventSignature);\n            if (!targetLog) {\n                throw new Error(\"StateSynced event not found\");\n            }\n            const rootStateId = client.child.decodeParameters(targetLog.topics[1], ['uint256'])[0];\n            const rootStateIdBN = utils.BN.isBN(rootStateId) ? rootStateId : new utils.BN(rootStateId);\n            return new utils.BN(lastStateId).gte(\n                rootStateIdBN\n            );\n        });\n    }\n\n}","import { service } from \"../services\";\nimport { resolve, promiseResolve } from \".\";\n\ntype T_ABI_CACHE = {\n    [networkName: string]: {\n        [version: string]: {\n            address: any,\n            abi: {\n                [bridgeType: string]: {\n                    [contractName: string]: any\n                }\n            }\n        }\n    }\n};\n\nconst cache: T_ABI_CACHE = {};\n\nexport class ABIManager {\n    constructor(public networkName: string, public version: string) {\n\n    }\n\n    init() {\n        return service.abi.getAddress(\n            this.networkName, this.version\n        ).then(result => {\n            cache[this.networkName] = {\n                [this.version]: {\n                    address: result,\n                    abi: {}\n                }\n            };\n        });\n    }\n\n    getConfig(path: string) {\n        return resolve(\n            cache[this.networkName][this.version].address,\n            path\n        );\n    }\n\n    getABI(contractName: string, bridgeType = 'plasma'): Promise<any> {\n        let targetBridgeABICache;\n\n        if (\n            cache[this.networkName] && cache[this.networkName][this.version] &&\n            cache[this.networkName][this.version].abi\n        ) {\n            targetBridgeABICache = cache[this.networkName][this.version].abi[bridgeType];\n        }\n\n\n        if (targetBridgeABICache) {\n            const abiForContract = targetBridgeABICache[contractName];\n            if (abiForContract) {\n                return promiseResolve<any>(abiForContract);\n            }\n        }\n        return service.abi.getABI(\n            this.networkName,\n            this.version,\n            bridgeType,\n            contractName\n        ).then(result => {\n            this.setABI(contractName, bridgeType, result);\n            return result;\n        });\n    }\n\n    setABI(contractName: string, bridgeType: string, abi: any) {\n        const abiStore = cache[this.networkName][this.version].abi;\n        if (!abiStore[bridgeType]) {\n            abiStore[bridgeType] = {};\n        }\n        abiStore[bridgeType][contractName] = abi;\n    }\n}","export const throwNotImplemented = <T>() => {\n    throw new Error(\"not implemented\");\n    return '' as any as T;\n};","import { Web3SideChainClient } from \".\";\nimport { BridgeUtil, ZkEvmBridge } from \"../zkevm\";\nimport { service } from \"../services\";\nimport { IBaseClientConfig } from \"..\";\n\nexport class ZkEvmBridgeClient {\n\n    client: Web3SideChainClient<IBaseClientConfig> = new Web3SideChainClient();\n    bridgeUtil: BridgeUtil;\n    rootChainBridge: ZkEvmBridge;\n    childChainBridge: ZkEvmBridge;\n\n    /**\n     * check whether a txHash is synced with child chain\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isDepositClaimable(txHash: string) {\n        return Promise.all([this.rootChainBridge.networkID(), this.bridgeUtil.getBridgeLogData(\n            txHash, true\n        )]).then(result => {\n            return service.zkEvmNetwork.getBridgeTransactionDetails(\n                this.client.config.version,\n                result[0],\n                result[1].depositCount\n            );\n        }).then(details => {\n            return details.ready_for_claim;\n        });\n    }\n\n    /**\n     * check whether proof is submitted on parent chain\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isWithdrawExitable(txHash: string) {\n        return Promise.all([this.childChainBridge.networkID(), this.bridgeUtil.getBridgeLogData(\n            txHash, false\n        )]).then(result => {\n            return service.zkEvmNetwork.getBridgeTransactionDetails(\n                this.client.config.version,\n                result[0],\n                result[1].depositCount\n            );\n        }).then(details => {\n            return details.ready_for_claim;\n        });\n    }\n\n    /**\n     * check whether deposit is completed\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isDeposited(txHash: string) {\n        return this.bridgeUtil.getBridgeLogData(\n            txHash, true\n        ).then(result => {\n            return this.childChainBridge.isClaimed(result.depositCount, 0);\n        });\n    }\n\n    /**\n     * check whether deposit is completed\n     *\n     * @param {string} txHash\n     * @returns\n     * @memberof ZkEvmBridgeClient\n     */\n    isExited(txHash: string) {\n        return this.bridgeUtil.getBridgeLogData(\n            txHash, false\n        ).then(result => {\n            return this.rootChainBridge.isClaimed(result.depositCount, 1);\n        });\n    }\n\n}\n","import { BaseWeb3Client } from \"../abstracts\";\nimport { EmptyBigNumber } from \"../implementation\";\nimport { Converter } from \"./converter\";\n\nexport * from \"./use\";\nexport * from \"./event_bus\";\nexport * from \"./logger\";\nexport * from \"./merge\";\nexport * from \"./map_promise\";\nexport * from \"./proof_util\";\nexport * from \"./http_request\";\nexport * from \"./converter\";\nexport * from \"./web3_side_chain_client\";\nexport * from \"./base_token\";\nexport * from \"./set_proof_api_url\";\nexport * from \"./resolve\";\nexport * from \"./promise_resolve\";\nexport * from \"./bridge_client\";\nexport * from \"./abi_manager\";\nexport * from \"./not_implemented\";\nexport * from \"./zkevm_bridge_client\";\nexport * from \"./buffer-utils\";\nexport * from \"./keccak\";\nexport * from \"./types\";\n\nexport const utils = {\n    converter: Converter,\n    Web3Client: BaseWeb3Client,\n    BN: EmptyBigNumber,\n    UnstoppableDomains: Object\n};\n","import { BaseToken, Web3SideChainClient, promiseResolve } from \"../utils\";\nimport { IContractInitParam, IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { IPOSContracts } from \"../interfaces\";\n\nexport class POSToken extends BaseToken<IPOSClientConfig> {\n\n    private predicateAddress: string;\n\n    constructor(\n        contractParam: IContractInitParam,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        protected getPOSContracts: () => IPOSContracts\n    ) {\n        super(contractParam, client);\n    }\n\n    protected get rootChainManager() {\n        return this.getPOSContracts().rootChainManager;\n    }\n\n    protected get gasSwapper() {\n        return this.getPOSContracts().gasSwapper;\n    }\n\n    protected get exitUtil() {\n        return this.getPOSContracts().exitUtil;\n    }\n\n\n    getPredicateAddress(): Promise<string> {\n        if (this.predicateAddress) {\n            return promiseResolve(this.predicateAddress);\n        }\n        return this.rootChainManager.method(\n            \"tokenToType\",\n            this.contractParam.address\n        ).then(method => {\n            return method.read();\n        }).then(tokenType => {\n            if (!tokenType) {\n                throw new Error('Invalid Token Type');\n            }\n            return this.rootChainManager.method(\n                \"typeToPredicate\", tokenType\n            );\n        }).then(typeToPredicateMethod => {\n            return typeToPredicateMethod.read<string>();\n        }).then(predicateAddress => {\n            this.predicateAddress = predicateAddress;\n            return predicateAddress;\n        });\n    }\n\n    protected isWithdrawn(txHash: string, eventSignature: string) {\n        if (!txHash) {\n            throw new Error(`txHash not provided`);\n        }\n        return this.exitUtil.getExitHash(\n            txHash, 0, eventSignature\n        ).then(exitHash => {\n            return this.rootChainManager.isExitProcessed(\n                exitHash\n            );\n        });\n    }\n\n    protected isWithdrawnOnIndex(txHash: string, index: number, eventSignature: string) {\n      if (!txHash) {\n          throw new Error(`txHash not provided`);\n      }\n      return this.exitUtil.getExitHash(\n          txHash, index, eventSignature\n      ).then(exitHash => {\n          return this.rootChainManager.isExitProcessed(\n              exitHash\n          );\n      });\n  }\n\n    protected withdrawExitPOS(burnTxHash: string, eventSignature: string, isFast: boolean, option: ITransactionOption) {\n        return this.exitUtil.buildPayloadForExit(\n            burnTxHash,\n            eventSignature,\n            isFast\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n}\n","import { ITransactionOption } from \"../interfaces\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERROR_TYPE, Log_Event_Signature } from \"../enums\";\nimport { MAX_AMOUNT, promiseResolve } from \"..\";\nimport { IAllowanceTransactionOption, IApproveTransactionOption, IExitTransactionOption, IPOSClientConfig, IPOSContracts } from \"../interfaces\";\n\nexport class ERC20 extends POSToken {\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC20',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    getBalance(userAddress: string, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * get allowance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getAllowance(userAddress: string, option: IAllowanceTransactionOption = {}) {\n        const spenderAddress = option.spenderAddress;\n\n        const predicatePromise = spenderAddress ? promiseResolve(spenderAddress) : this.getPredicateAddress();\n\n        return Promise.all([predicatePromise, this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"allowance\",\n                userAddress,\n                predicateAddress,\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    approve(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        const spenderAddress = option.spenderAddress;\n\n        if (!spenderAddress && !this.contractParam.isParent) {\n            this.client.logger.error(ERROR_TYPE.NullSpenderAddress).throw();\n        }\n\n        const predicatePromise = spenderAddress ? promiseResolve(spenderAddress) : this.getPredicateAddress();\n\n        return Promise.all([predicatePromise, this.getContract()]).then(result => {\n            const [predicateAddress, contract] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveMax(option: IApproveTransactionOption = {}) {\n        return this.approve(\n            MAX_AMOUNT\n            , option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    deposit(amount: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user along with ETHER for gas token\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositWithGas(amount: TYPE_AMOUNT, userAddress: string, swapEthAmount: TYPE_AMOUNT, swapCallData: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        return this.getChainId().then((chainId: number) => {\n            if (chainId !== 1) {\n                this.client.logger.error(ERROR_TYPE.AllowedOnMainnet).throw();\n            }\n            const amountInABI = this.client.parent.encodeParameters(\n                [Converter.toHex(amount)],\n                ['uint256'],\n            );\n\n            option.value = Converter.toHex(swapEthAmount);\n\n            return this.gasSwapper.depositWithGas(\n                this.contractParam.address,\n                amountInABI,\n                userAddress,\n                swapCallData,\n                option\n            );\n        });\n\n    }\n\n    private depositEther_(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption = {}) {\n        this.checkForRoot(\"depositEther\");\n\n\n        option.value = Converter.toHex(amount);\n        return this.rootChainManager.method(\"depositEtherFor\", userAddress).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    private depositEtherWithGas_(amount: TYPE_AMOUNT, userAddress: string, swapEthAmount: TYPE_AMOUNT, swapCallData: string, option: ITransactionOption = {}) {\n        this.checkForRoot(\"depositEtherWithGas\");\n\n        return this.getChainId().then((chainId: number) => {\n            if (chainId !== 1) {\n                this.client.logger.error(ERROR_TYPE.AllowedOnMainnet).throw();\n            }\n            const amountInABI = this.client.parent.encodeParameters(\n                [Converter.toHex(amount)],\n                ['uint256'],\n            );\n\n            option.value = Converter.toHex(\n                Converter.toBN(amount).add(\n                    Converter.toBN(swapEthAmount)\n                )\n            );\n\n            return this.gasSwapper.depositWithGas(\n                \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\",\n                amountInABI,\n                userAddress,\n                swapCallData,\n                option\n            );\n        });\n    }\n\n    /**\n     * initiate withdraw by burning provided amount\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawStart(amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    private withdrawExit_(burnTransactionHash: string, isFast: boolean, option: IExitTransactionOption = {}) {\n        const eventSignature = option.burnEventSignature ?\n            option.burnEventSignature : Log_Event_Signature.Erc20Transfer;\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            eventSignature,\n            isFast\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExit(burnTransactionHash: string, option?: IExitTransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.withdrawExit_(burnTransactionHash, false, option);\n    }\n\n    /**\n     * complete withdraw process after checkpoint has been submitted for the block containing burn tx.\n     *\n     *  Note:- It create the proof in api call for fast exit.\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: IExitTransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.withdrawExit_(burnTransactionHash, true, option);\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @returns\n     * @memberof ERC20\n     */\n    isWithdrawExited(burnTxHash: string) {\n        return this.isWithdrawn(burnTxHash, Log_Event_Signature.Erc20Transfer);\n    }\n\n    /**\n     * transfer amount to another user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    transfer(amount: TYPE_AMOUNT, to: string, option?: ITransactionOption) {\n        return this.transferERC20(to, amount, option);\n    }\n\n}\n","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class RootChainManager extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChainManager',\n            bridgeType: 'pos',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    deposit(userAddress: string, tokenAddress: string, depositData: string, option?: ITransactionOption) {\n        return this.method(\n            \"depositFor\",\n            userAddress,\n            tokenAddress,\n            depositData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    exit(exitPayload: string, option: ITransactionOption) {\n        return this.method(\"exit\", exitPayload).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    isExitProcessed(exitHash: string) {\n        return this.method(\n            \"processedExits\", exitHash\n        ).then(method => {\n            return this.processRead<boolean>(method);\n        });\n    }\n\n}\n","import { RootChain } from \"./root_chain\";\nimport { Converter, ProofUtil, Web3SideChainClient } from \"../utils\";\nimport { BufferUtil } from \"../utils/buffer-utils\";\nimport rlp from \"rlp\";\nimport { IBlockWithTransaction, ITransactionReceipt } from \"../interfaces\";\nimport { service } from \"../services\";\nimport { BaseBigNumber, BaseWeb3Client } from \"../abstracts\";\nimport { ErrorHelper } from \"../utils/error_helper\";\nimport { ERROR_TYPE, IBaseClientConfig, IRootBlockInfo, utils } from \"..\";\n\ninterface IChainBlockInfo {\n    lastChildBlock: string;\n    txBlockNumber: number;\n}\n\n\n\nexport class ExitUtil {\n    private maticClient_: BaseWeb3Client;\n\n    rootChain: RootChain;\n\n    requestConcurrency: number;\n    config: IBaseClientConfig;\n\n    constructor(client: Web3SideChainClient<IBaseClientConfig>, rootChain: RootChain) {\n        this.maticClient_ = client.child;\n        this.rootChain = rootChain;\n        const config = client.config;\n        this.config = config;\n        this.requestConcurrency = config.requestConcurrency;\n    }\n\n    private getLogIndex_(logEventSig: string, receipt: ITransactionReceipt) {\n        let logIndex = -1;\n\n        switch (logEventSig) {\n            case '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef':\n            case '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            case '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62':\n            case '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb':\n                logIndex = receipt.logs.findIndex(\n                    log =>\n                        log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[3].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000'\n                );\n                break;\n\n            default:\n                logIndex = receipt.logs.findIndex(log => log.topics[0].toLowerCase() === logEventSig.toLowerCase());\n        }\n        if (logIndex < 0) {\n            throw new Error(\"Log not found in receipt\");\n        }\n        return logIndex;\n    }\n\n    private getAllLogIndices_(logEventSig: string, receipt: ITransactionReceipt) {\n        let logIndices = [];\n\n        switch (logEventSig) {\n            case '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef':\n            case '0xf94915c6d1fd521cee85359239227480c7e8776d7caf1fc3bacad5c269b66a14':\n                logIndices = receipt.logs.reduce(\n                    (_, log, index) =>\n                    ((log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000') &&\n                        logIndices.push(index), logIndices), []\n                );\n                break;\n\n            case '0xc3d58168c5ae7397731d063d5bbf3d657854427343f4c083240f7aacaa2d0f62':\n            case '0x4a39dc06d4c0dbc64b70af90fd698a233a518aa5d07e595d983b8c0526c8f7fb':\n                logIndices = receipt.logs.reduce(\n                    (_, log, index) =>\n                    ((log.topics[0].toLowerCase() === logEventSig.toLowerCase() &&\n                        log.topics[3].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000') &&\n                        logIndices.push(index), logIndices), []\n                );\n                break;\n\n            case '0xf871896b17e9cb7a64941c62c188a4f5c621b86800e3d15452ece01ce56073df':\n                logIndices = receipt.logs.reduce(\n                    (_, log, index) =>\n                    ((log.topics[0].toLowerCase() === '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef' &&\n                        log.topics[2].toLowerCase() === '0x0000000000000000000000000000000000000000000000000000000000000000') &&\n                        logIndices.push(index), logIndices), []\n                );\n                break;\n\n            default:\n                logIndices = receipt.logs.reduce(\n                    (_, log, index) =>\n                    ((log.topics[0].toLowerCase() === logEventSig.toLowerCase()) &&\n                        logIndices.push(index), logIndices), []\n                );\n        }\n        if (logIndices.length === 0) {\n            throw new Error(\"Log not found in receipt\");\n        }\n        return logIndices;\n    }\n\n    getChainBlockInfo(burnTxHash: string) {\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransaction(burnTxHash),\n        ]).then(result => {\n            return {\n                lastChildBlock: result[0],\n                txBlockNumber: result[1].blockNumber\n            } as IChainBlockInfo;\n        });\n    }\n\n    private isCheckPointed_(data: IChainBlockInfo) {\n        // lastchild block is greater equal to transaction block number; \n        return new utils.BN(data.lastChildBlock).gte(\n            new utils.BN(data.txBlockNumber)\n        );\n    }\n\n    isCheckPointed(burnTxHash: string) {\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(result => {\n            return this.isCheckPointed_(\n                result\n            );\n        });\n    }\n\n    /**\n     * returns info about block number existence on parent chain\n     * 1. root block number, \n     * 2. start block number, \n     * 3. end block number \n     *\n     * @private\n     * @param {number} txBlockNumber - transaction block number on child chain\n     * @return {*} \n     * @memberof ExitUtil\n     */\n    private getRootBlockInfo(txBlockNumber: number) {\n        // find in which block child was included in parent\n        let rootBlockNumber: BaseBigNumber;\n        return this.rootChain.findRootBlockFromChild(\n            txBlockNumber\n        ).then(blockNumber => {\n            rootBlockNumber = blockNumber;\n            return this.rootChain.method(\n                \"headerBlocks\",\n                Converter.toHex(blockNumber)\n            );\n        }).then(method => {\n            return method.read<IRootBlockInfo>();\n        }).then(rootBlockInfo => {\n            return {\n                // header block number - root block number in which child block exist \n                headerBlockNumber: rootBlockNumber,\n                // range of block\n                // end - block end number\n                end: rootBlockInfo.end.toString(),\n                // start - block start number\n                start: rootBlockInfo.start.toString(),\n            } as IRootBlockInfo;\n        });\n\n    }\n\n    private getRootBlockInfoFromAPI(txBlockNumber: number) {\n        this.maticClient_.logger.log(\"block info from API 1\");\n        return service.network.getBlockIncluded(\n            this.config.version,\n            txBlockNumber\n        ).then(headerBlock => {\n            this.maticClient_.logger.log(\"block info from API 2\", headerBlock);\n            if (!headerBlock || !headerBlock.start || !headerBlock.end || !headerBlock.headerBlockNumber) {\n                throw Error('Network API Error');\n            }\n            return headerBlock;\n        }).catch(err => {\n            this.maticClient_.logger.log(\"block info from API\", err);\n            return this.getRootBlockInfo(txBlockNumber);\n        });\n    }\n\n    getBlockProof(txBlockNumber: number, rootBlockInfo: { start, end }) {\n        return ProofUtil.buildBlockProof(\n            this.maticClient_,\n            parseInt(rootBlockInfo.start, 10),\n            parseInt(rootBlockInfo.end, 10),\n            parseInt(txBlockNumber + '', 10)\n        );\n    }\n\n    private getBlockProofFromAPI(txBlockNumber: number, rootBlockInfo: { start, end }) {\n\n        return service.network.getProof(\n            this.config.version,\n            rootBlockInfo.start,\n            rootBlockInfo.end,\n            txBlockNumber\n        ).then(blockProof => {\n            if (!blockProof) {\n                throw Error('Network API Error');\n            }\n            this.maticClient_.logger.log(\"block proof from API 1\");\n            return blockProof;\n        }).catch(_ => {\n            return this.getBlockProof(txBlockNumber, rootBlockInfo);\n        });\n    }\n\n    private getExitProofFromAPI(burnHash: string, eventSignature: string) {\n\n        return service.network.getExitProof(\n            this.config.version, burnHash, eventSignature\n        ).then(exitProof => {\n            if (!exitProof) {\n                throw Error('Network API Error');\n            }\n            this.maticClient_.logger.log(\"exit proof from API 1\");\n            return exitProof;\n        }).catch(_ => {\n            return this.buildPayloadForExit(burnHash, eventSignature, false);\n        });\n    }\n\n    buildPayloadForExit(burnTxHash: string, logEventSig: string, isFast: boolean, index = 0) {\n\n        if (isFast && !service.network) {\n            new ErrorHelper(ERROR_TYPE.ProofAPINotSet).throw();\n        }\n\n        if (index < 0) {\n            throw new Error('Index must not be a negative integer');\n        }\n\n        let txBlockNumber: number,\n            rootBlockInfo: IRootBlockInfo,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction,\n            blockProof;\n\n        if (isFast) {\n            return this.getExitProofFromAPI(burnTxHash, logEventSig);\n        }\n\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(blockInfo => {\n            if (!this.isCheckPointed_(blockInfo)) {\n                throw new Error(\n                    'Burn transaction has not been checkpointed as yet'\n                );\n            }\n\n            // step 1 - Get Block number from transaction hash\n            txBlockNumber = blockInfo.txBlockNumber;\n            // step 2-  get transaction receipt from txhash and \n            // block information from block number\n            return Promise.all([\n                this.maticClient_.getTransactionReceipt(burnTxHash),\n                this.maticClient_.getBlockWithTransaction(txBlockNumber)\n            ]);\n        }).then(result => {\n            [receipt, block] = result;\n            // step  3 - get information about block saved in parent chain \n            return this.getRootBlockInfo(txBlockNumber);\n        }).then(rootBlockInfoResult => {\n            rootBlockInfo = rootBlockInfoResult;\n            // step 4 - build block proof\n            return this.getBlockProof(txBlockNumber, rootBlockInfo);\n        }).then(blockProofResult => {\n            blockProof = blockProofResult;\n            // step 5- create receipt proof\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            // step 6 - encode payload, convert into hex\n\n            // when token index is not 0\n            if (index > 0) {\n                const logIndices = this.getAllLogIndices_(\n                    logEventSig, receipt\n                );\n\n                if (index >= logIndices.length) {\n                    throw new Error('Index is greater than the number of tokens in this transaction');\n                }\n\n                return this.encodePayload_(\n                    rootBlockInfo.headerBlockNumber.toNumber(),\n                    blockProof,\n                    txBlockNumber,\n                    block.timestamp,\n                    Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                    Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                    ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                    receiptProof.parentNodes,\n                    receiptProof.path,\n                    logIndices[index]\n                );\n            }\n\n            // when token index is 0\n            const logIndex = this.getLogIndex_(\n                logEventSig, receipt\n            );\n\n            return this.encodePayload_(\n                rootBlockInfo.headerBlockNumber.toNumber(),\n                blockProof,\n                txBlockNumber,\n                block.timestamp,\n                Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                receiptProof.parentNodes,\n                receiptProof.path,\n                logIndex\n            );\n        });\n    }\n\n    buildMultiplePayloadsForExit(burnTxHash: string, logEventSig: string, isFast: boolean) {\n\n        if (isFast && !service.network) {\n            new ErrorHelper(ERROR_TYPE.ProofAPINotSet).throw();\n        }\n\n        let txBlockNumber: number,\n            rootBlockInfo: IRootBlockInfo,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction,\n            blockProof;\n\n        return this.getChainBlockInfo(\n            burnTxHash\n        ).then(blockInfo => {\n            if (!isFast && !this.isCheckPointed_(blockInfo)) {\n                throw new Error(\n                    'Burn transaction has not been checkpointed as yet'\n                );\n            }\n\n            // step 1 - Get Block number from transaction hash\n            txBlockNumber = blockInfo.txBlockNumber;\n            // step 2-  get transaction receipt from txhash and \n            // block information from block number\n            return Promise.all([\n                this.maticClient_.getTransactionReceipt(burnTxHash),\n                this.maticClient_.getBlockWithTransaction(txBlockNumber)\n            ]);\n        }).then(result => {\n            [receipt, block] = result;\n            // step  3 - get information about block saved in parent chain \n            return (\n                isFast ? this.getRootBlockInfoFromAPI(txBlockNumber) :\n                    this.getRootBlockInfo(txBlockNumber)\n            );\n        }).then(rootBlockInfoResult => {\n            rootBlockInfo = rootBlockInfoResult;\n            // step 4 - build block proof\n            return (\n                isFast ? this.getBlockProofFromAPI(txBlockNumber, rootBlockInfo) :\n                    this.getBlockProof(txBlockNumber, rootBlockInfo)\n            );\n        }).then(blockProofResult => {\n            blockProof = blockProofResult;\n            // step 5- create receipt proof\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            const logIndices = this.getAllLogIndices_(\n                logEventSig, receipt\n            );\n            const payloads: string[] = [];\n\n            // step 6 - encode payloads, convert into hex\n            for (const logIndex of logIndices) {\n                payloads.push(\n                    this.encodePayload_(\n                        rootBlockInfo.headerBlockNumber.toNumber(),\n                        blockProof,\n                        txBlockNumber,\n                        block.timestamp,\n                        Buffer.from(block.transactionsRoot.slice(2), 'hex'),\n                        Buffer.from(block.receiptsRoot.slice(2), 'hex'),\n                        ProofUtil.getReceiptBytes(receipt), // rlp encoded\n                        receiptProof.parentNodes,\n                        receiptProof.path,\n                        logIndex\n                    )\n                );\n            }\n\n            return payloads;\n        });\n    }\n\n    private encodePayload_(\n        headerNumber,\n        buildBlockProof,\n        blockNumber,\n        timestamp,\n        transactionsRoot,\n        receiptsRoot,\n        receipt,\n        receiptParentNodes,\n        path,\n        logIndex\n    ) {\n        return BufferUtil.bufferToHex(\n            rlp.encode([\n                headerNumber,\n                buildBlockProof,\n                blockNumber,\n                timestamp,\n                BufferUtil.bufferToHex(transactionsRoot),\n                BufferUtil.bufferToHex(receiptsRoot),\n                BufferUtil.bufferToHex(receipt),\n                BufferUtil.bufferToHex(rlp.encode(receiptParentNodes) as Buffer),\n                BufferUtil.bufferToHex(Buffer.concat([Buffer.from('00', 'hex'), path])),\n                logIndex,\n            ]) as Buffer\n        );\n    }\n\n    getExitHash(burnTxHash, index, logEventSig) {\n        let lastChildBlock: string,\n            receipt: ITransactionReceipt,\n            block: IBlockWithTransaction;\n\n        return Promise.all([\n            this.rootChain.getLastChildBlock(),\n            this.maticClient_.getTransactionReceipt(burnTxHash)\n        ]).then(result => {\n            lastChildBlock = result[0];\n            receipt = result[1];\n            return this.maticClient_.getBlockWithTransaction(\n                receipt.blockNumber\n            );\n        }).then(blockResult => {\n            block = blockResult;\n            if (!this.isCheckPointed_({ lastChildBlock: lastChildBlock, txBlockNumber: receipt.blockNumber })) {\n                this.maticClient_.logger.error(ERROR_TYPE.BurnTxNotCheckPointed).throw();\n            }\n            return ProofUtil.getReceiptProof(\n                receipt,\n                block,\n                this.maticClient_,\n                this.requestConcurrency\n            );\n        }).then((receiptProof: any) => {\n            let logIndex;\n            const nibbleArr = [];\n            receiptProof.path.forEach(byte => {\n                nibbleArr.push(Buffer.from('0' + (byte / 0x10).toString(16), 'hex'));\n                nibbleArr.push(Buffer.from('0' + (byte % 0x10).toString(16), 'hex'));\n            });\n\n            if (index > 0) {\n                const logIndices = this.getAllLogIndices_(logEventSig, receipt);\n                logIndex = logIndices[index];\n            }\n\n            logIndex = this.getLogIndex_(logEventSig, receipt);\n\n            return this.maticClient_.etheriumSha3(\n                receipt.blockNumber, BufferUtil.bufferToHex(Buffer.concat(nibbleArr)), logIndex\n            );\n        });\n    }\n}\n","import { BaseToken, utils, Web3SideChainClient } from \"../utils\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { BaseBigNumber } from \"..\";\n\nexport class RootChain extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'RootChain',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    getLastChildBlock() {\n        return this.method(\"getLastChildBlock\").then(method => {\n            return method.read<string>({}, this.client.config.rootChainDefaultBlock || 'safe');\n        });\n    }\n\n    async findRootBlockFromChild(childBlockNumber: TYPE_AMOUNT): Promise<BaseBigNumber> {\n        const bigOne = new utils.BN(1);\n        const bigtwo = new utils.BN(2);\n        const checkPointInterval = new utils.BN(10000);\n\n        childBlockNumber = new utils.BN(childBlockNumber);\n        // first checkpoint id = start * 10000\n        let start = bigOne;\n\n        // last checkpoint id = end * 10000\n        const method = await this.method(\"currentHeaderBlock\");\n        const currentHeaderBlock = await method.read<string>();\n        let end = new utils.BN(currentHeaderBlock).div(\n            checkPointInterval\n        );\n\n        // binary search on all the checkpoints to find the checkpoint that contains the childBlockNumber\n        let ans;\n        while (start.lte(end)) {\n            if (start.eq(end)) {\n                ans = start;\n                break;\n            }\n            const mid = start.add(end).div(bigtwo);\n            const headerBlocksMethod = await this.method(\n                \"headerBlocks\",\n                mid.mul(checkPointInterval).toString()\n            );\n            const headerBlock = await headerBlocksMethod.read<{ start: number, end: number }>();\n\n            const headerStart = new utils.BN(headerBlock.start);\n            const headerEnd = new utils.BN(headerBlock.end);\n\n            if (headerStart.lte(childBlockNumber) && childBlockNumber.lte(headerEnd)) {\n                // if childBlockNumber is between the upper and lower bounds of the headerBlock, we found our answer\n                ans = mid;\n                break;\n            } else if (headerStart.gt(childBlockNumber)) {\n                // childBlockNumber was checkpointed before this header\n                end = mid.sub(bigOne);\n            } else if (headerEnd.lt(childBlockNumber)) {\n                // childBlockNumber was checkpointed after this header\n                start = mid.add(bigOne);\n            }\n        }\n        return ans.mul(checkPointInterval);\n    }\n\n}\n","import { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { Converter, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ExitUtil } from \"./exit_util\";\nimport { Log_Event_Signature } from \"../enums\";\n\nexport class ERC721 extends POSToken {\n\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC721',\n            bridgeType: 'pos'\n        }, client, getContracts);\n    }\n\n    private validateMany_(tokenIds) {\n        if (tokenIds.length > 20) {\n            throw new Error('can not process more than 20 tokens');\n        }\n        return tokenIds.map(tokenId => {\n            return Converter.toHex(tokenId);\n        });\n    }\n\n    /**\n     * get tokens count for the user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokensCount(userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress\n            );\n            return this.processRead<string>(method, options);\n        }).then(count => {\n            return Number(count);\n        });\n    }\n\n    /**\n     * returns token id on supplied index for user\n     *\n     * @param {number} index\n     * @param {string} userAddress\n     * @param {ITransactionOption} [options]\n     * @returns\n     * @memberof ERC721\n     */\n    getTokenIdAtIndexForUser(index: number, userAddress: string, options?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"tokenOfOwnerByIndex\",\n                userAddress,\n                index\n            );\n\n            return this.processRead<string>(method, options);\n        });\n    }\n\n    /**\n     * get all tokens for user\n     *\n     * @param {string} userAddress\n     * @param {*} [limit=Infinity]\n     * @returns\n     * @memberof ERC721\n     */\n    getAllTokens(userAddress: string, limit = Infinity) {\n        return this.getTokensCount(userAddress).then(count => {\n            count = Number(count);\n            if (count > limit) {\n                count = limit;\n            }\n            const promises = [];\n            for (let i = 0; i < count; i++) {\n                promises.push(\n                    this.getTokenIdAtIndexForUser(i, userAddress)\n                );\n            }\n            return Promise.all(\n                promises\n            );\n        });\n    }\n\n    isApproved(tokenId: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApproved\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"getApproved\",\n                tokenId\n            );\n            return Promise.all([\n                this.processRead<string>(method, option),\n                this.getPredicateAddress()\n            ]).then(result => {\n                return result[0] === result[1];\n            });\n        });\n    }\n\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    approve(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"approve\",\n                predicateAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approveAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n\n    deposit(tokenId: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(tokenId)],\n            ['uint256'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    depositMany(tokenIds: TYPE_AMOUNT[], userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [tokensInHex],\n            ['uint256[]'],\n        );\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n    }\n\n    withdrawStart(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdraw\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartWithMetaData(tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartWithMetaData\");\n\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawWithMetadata\",\n                Converter.toHex(tokenId)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = this.validateMany_(tokenIds);\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            false\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    withdrawExitOnIndex(burnTransactionHash: string, index: number, option?: ITransactionOption) {\n      this.checkForRoot(\"withdrawExit\");\n\n      return this.exitUtil.buildPayloadForExit(\n          burnTransactionHash,\n          Log_Event_Signature.Erc721Transfer,\n          false,\n          index\n      ).then(payload => {\n          return this.rootChainManager.exit(\n              payload, option\n          );\n      });\n    }\n\n    // async withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n    //     this.checkForRoot(\"withdrawExitMany\");\n\n    //     return this.exitUtil.buildMultiplePayloadsForExit(\n    //         burnTransactionHash,\n    //         Log_Event_Signature.Erc721BatchTransfer,\n    //         false\n    //     ).then(async payloads => {\n    //         const exitTxs = [];\n    //         if()\n    //         for(const i in payloads) {\n    //           exitTxs.push(this.rootChainManager.exit(\n    //             payloads[i], option\n    //         ));\n    //         }\n    //         return Promise.all(exitTxs);\n    //         });\n    // }\n\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.exitUtil.buildPayloadForExit(\n            burnTransactionHash,\n            Log_Event_Signature.Erc721Transfer,\n            true\n        ).then(payload => {\n            return this.rootChainManager.exit(\n                payload, option\n            );\n        });\n    }\n\n    // withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n    //     this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n    //     return this.exitUtil.buildPayloadForExit(\n    //         burnTransactionHash,\n    //         Log_Event_Signature.Erc721BatchTransfer,\n    //         true\n    //     ).then(payload => {\n    //         return this.rootChainManager.exit(\n    //             payload, option\n    //         );\n    //     });\n    // }\n\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721Transfer\n        );\n    }\n\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc721BatchTransfer\n        );\n    }\n\n    isWithdrawExitedOnIndex(txHash: string, index: number) {\n        return this.isWithdrawnOnIndex(\n            txHash, index, Log_Event_Signature.Erc721Transfer\n        );\n    }\n\n    /**\n     * transfer to another user\n     *\n     * @param {string} tokenId\n     * @param {string} from\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC721\n     */\n    transfer(tokenId: string, from: string, to: string, option?: ITransactionOption) {\n        return this.transferERC721(\n            from,\n            to,\n            tokenId,\n            option\n        );\n    }\n\n}\n","import { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\nimport { Converter, promiseResolve, Web3SideChainClient } from \"../utils\";\nimport { POSToken } from \"./pos_token\";\nimport { Log_Event_Signature } from \"../enums\";\nimport { IPOSContracts, IPOSERC1155Address } from \"../interfaces\";\nimport { POSERC1155DepositBatchParam, POSERC1155DepositParam, POSERC1155TransferParam, TYPE_AMOUNT } from \"..\";\n\nexport class ERC1155 extends POSToken {\n\n    mintablePredicateAddress: string;\n\n    get addressConfig(): IPOSERC1155Address {\n        return this.client.config.erc1155 || {};\n    }\n\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        client: Web3SideChainClient<IPOSClientConfig>,\n        getContracts: () => IPOSContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            name: 'ChildERC1155',\n            bridgeType: 'pos'\n        }, client, getContracts);\n\n    }\n\n    private getAddress_(value: string) {\n        const addresses = this.addressConfig;\n        if (addresses[value]) {\n            return promiseResolve(addresses[value]);\n        }\n\n        return this.client.getConfig(value);\n    }\n\n    /**\n     * get balance of a user for supplied token\n     *\n     * @param {string} userAddress\n     * @param {TYPE_AMOUNT} tokenId\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    getBalance(userAddress: string, tokenId: TYPE_AMOUNT, option?: ITransactionOption) {\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"balanceOf\",\n                userAddress,\n                Converter.toHex(tokenId)\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * check if a user is approved for all tokens\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isApprovedAll(userAddress: string, option?: ITransactionOption) {\n        this.checkForRoot(\"isApprovedAll\");\n\n        return Promise.all([this.getContract(), this.getPredicateAddress()]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"isApprovedForAll\",\n                userAddress,\n                predicateAddress\n            );\n            return this.processRead<boolean>(method, option);\n        });\n\n    }\n\n    private approveAll_(predicateAddressPromise: Promise<string>, option: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return Promise.all([this.getContract(), predicateAddressPromise]).then(result => {\n            const [contract, predicateAddress] = result;\n            const method = contract.method(\n                \"setApprovalForAll\",\n                predicateAddress,\n                true\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * approve all tokens \n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAll(option?: ITransactionOption) {\n        this.checkForRoot(\"approve\");\n\n        return this.approveAll_(\n            this.getPredicateAddress(), option\n        );\n    }\n\n    /**\n     * approve all tokens for mintable token\n     *\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    approveAllForMintable(option?: ITransactionOption) {\n        this.checkForRoot(\"approveForMintable\");\n        const addressPath = \"Main.POSContracts.MintableERC1155PredicateProxy\";\n        return this.approveAll_(\n            this.getAddress_(addressPath), option\n        );\n    }\n\n    /**\n     * deposit supplied amount of token for a user \n     *\n     * @param {POSERC1155DepositParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    deposit(param: POSERC1155DepositParam, option?: ITransactionOption) {\n        this.checkForRoot(\"deposit\");\n        return this.depositMany({\n            amounts: [param.amount],\n            tokenIds: [param.tokenId],\n            userAddress: param.userAddress,\n            data: param.data\n        }, option);\n    }\n\n    /**\n     * deposit supplied amount of multiple token for user\n     *\n     * @param {POSERC1155DepositBatchParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    depositMany(param: POSERC1155DepositBatchParam, option?: ITransactionOption) {\n        this.checkForRoot(\"depositMany\");\n\n        const { tokenIds, amounts, data, userAddress } = param;\n        const emptyHex = Converter.toHex(0);\n        const amountInABI = this.client.parent.encodeParameters(\n            [\n                tokenIds.map(t => Converter.toHex(t)),\n                amounts.map(a => Converter.toHex(a)),\n                data || emptyHex\n            ],\n            ['uint256[]', 'uint256[]', 'bytes'],\n        );\n\n        return this.rootChainManager.deposit(\n            userAddress,\n            this.contractParam.address,\n            amountInABI,\n            option\n        );\n\n    }\n\n    /**\n     * start withdraw process by burning the required amount for a token\n     *\n     * @param {string} tokenId\n     * @param {TYPE_AMOUNT} amount\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStart(tokenId: TYPE_AMOUNT, amount: TYPE_AMOUNT, option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStart\");\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawSingle\",\n                Converter.toHex(tokenId),\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * start the withdraw process by burning the supplied amount of multiple token at a time\n     *\n     * @param {TYPE_AMOUNT[]} tokenIds\n     * @param {TYPE_AMOUNT[]} amounts\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawStartMany(tokenIds: TYPE_AMOUNT[], amounts: TYPE_AMOUNT[], option?: ITransactionOption) {\n        this.checkForChild(\"withdrawStartMany\");\n\n        const tokensInHex = tokenIds.map(t => {\n            return Converter.toHex(t);\n        });\n        const amountsInHex = amounts.map(t => {\n            return Converter.toHex(t);\n        });\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"withdrawBatch\",\n                tokensInHex,\n                amountsInHex\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process and get the burned amount on root chain\n     * \n     * the process is faster because it uses proof api\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFaster(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFaster\");\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155Transfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            false,\n            option\n        );\n    }\n\n    /**\n     * exit the withdraw process for many burned transaction and get the burned amount on root chain\n     *\n     * the process is faster because it uses proof api\n     * \n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    withdrawExitFasterMany(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExitFasterMany\");\n\n\n        return this.withdrawExitPOS(\n            burnTransactionHash,\n            Log_Event_Signature.Erc1155BatchTransfer,\n            true,\n            option\n        );\n    }\n\n    /**\n     * check if exit has been completed for a transaction hash\n     *\n     * @param {string} burnTxHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExited(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155Transfer\n        );\n    }\n\n    /**\n     * check if batch exit has been completed for a transaction hash\n     *\n     * @param {string} txHash\n     * @return {*} \n     * @memberof ERC1155\n     */\n    isWithdrawExitedMany(txHash: string) {\n        return this.isWithdrawn(\n            txHash, Log_Event_Signature.Erc1155BatchTransfer\n        );\n    }\n\n    /**\n     * transfer the required amount of a token to another user\n     *\n     * @param {POSERC1155TransferParam} param\n     * @param {ITransactionOption} [option]\n     * @return {*} \n     * @memberof ERC1155\n     */\n    transfer(param: POSERC1155TransferParam, option?: ITransactionOption) {\n        return this.transferERC1155(\n            param, option\n        );\n    }\n}","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IPOSClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class GasSwapper extends BaseToken<IPOSClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IPOSClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'GasSwapper',\n            bridgeType: 'pos',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    depositWithGas(\n        tokenAddress: string,\n        depositAmount: string,\n        userAddress: string,\n        swapCallData: string,\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"swapAndBridge\",\n            tokenAddress,\n            depositAmount,\n            userAddress,\n            swapCallData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n}\n","import { ERC20 } from \"./erc20\";\nimport { RootChainManager } from \"./root_chain_manager\";\nimport { BridgeClient } from \"../utils\";\nimport { IPOSClientConfig, IPOSContracts, ITransactionOption } from \"../interfaces\";\nimport { ExitUtil } from \"./exit_util\";\nimport { RootChain } from \"./root_chain\";\nimport { ERC721 } from \"./erc721\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { ERC1155 } from \"./erc1155\";\nimport { GasSwapper } from \"./gas_swapper\";\n\nexport * from \"./exit_util\";\nexport * from \"./root_chain_manager\";\nexport * from \"./root_chain\";\nexport * from \"./gas_swapper\";\n\nexport class POSClient extends BridgeClient<IPOSClientConfig> {\n\n    rootChainManager: RootChainManager;\n    gasSwapper: GasSwapper;\n\n    init(config: IPOSClientConfig) {\n        const client = this.client;\n\n        return client.init(config).then(_ => {\n            const mainPOSContracts = client.mainPOSContracts;\n            client.config = config = Object.assign(\n                {\n                    rootChainManager: mainPOSContracts.RootChainManagerProxy,\n                    rootChain: client.mainPlasmaContracts.RootChainProxy,\n                    gasSwapper: mainPOSContracts.GasSwapper\n                } as IPOSClientConfig,\n                config\n            );\n\n            this.rootChainManager = new RootChainManager(\n                this.client,\n                config.rootChainManager,\n            );\n\n            const rootChain = new RootChain(\n                this.client,\n                config.rootChain,\n            );\n\n            this.exitUtil = new ExitUtil(\n                this.client,\n                rootChain\n            );\n\n            this.gasSwapper = new GasSwapper(\n                this.client,\n                config.gasSwapper\n            );\n\n            return this;\n        });\n    }\n\n    erc20(tokenAddress, isParent?: boolean) {\n        return new ERC20(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc721(tokenAddress, isParent?: boolean) {\n        return new ERC721(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    erc1155(tokenAddress, isParent?: boolean) {\n        return new ERC1155(\n            tokenAddress,\n            isParent,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    depositEther(amount: TYPE_AMOUNT, userAddress: string, option: ITransactionOption) {\n        return new ERC20(\n            '', true, this.client,\n            this.getContracts_.bind(this),\n        )['depositEther_'](amount, userAddress, option);\n    }\n\n    depositEtherWithGas(\n        amount: TYPE_AMOUNT,\n        userAddress: string,\n        swapEthAmount: TYPE_AMOUNT,\n        swapCallData: string,\n        option: ITransactionOption\n    ) {\n        return new ERC20(\n            '', true, this.client,\n            this.getContracts_.bind(this),\n        )['depositEtherWithGas_'](amount, userAddress, swapEthAmount, swapCallData, option);\n    }\n\n    private getContracts_() {\n        return {\n            exitUtil: this.exitUtil,\n            rootChainManager: this.rootChainManager,\n            gasSwapper: this.gasSwapper\n        } as IPOSContracts;\n    }\n}","import { POSClient } from \"./pos\";\nimport { use, utils } from \"./utils\";\n\nexport const defaultExport = {\n    utils: utils,\n    use,\n    POSClient,\n};","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IContractInitParam, IZkEvmClientConfig } from \"../interfaces\";\nimport { IZkEvmContracts } from \"../interfaces\";\n\nexport class ZkEvmToken extends BaseToken<IZkEvmClientConfig> {\n\n    constructor(\n        contractParam: IContractInitParam,\n        client: Web3SideChainClient<IZkEvmClientConfig>,\n        protected getZkEvmContracts: () => IZkEvmContracts\n    ) {\n        super(contractParam, client);\n    }\n\n    protected get parentBridge() {\n        return this.getZkEvmContracts().parentBridge;\n    }\n\n    protected get zkEVMWrapper() {\n        return this.getZkEvmContracts().zkEVMWrapper;\n    }\n\n    protected get childBridge() {\n        return this.getZkEvmContracts().childBridge;\n    }\n\n    protected get bridgeUtil() {\n        return this.getZkEvmContracts().bridgeUtil;\n    }\n\n}\n","import { ITransactionOption, IZkEvmClientConfig } from '../interfaces';\nimport { BaseToken, Converter, Web3SideChainClient } from '../utils';\nimport { TYPE_AMOUNT } from '../types';\n\n/**\n * ZkEVMBridgeAdapter used ZkEVMBridge to implement additional custom features\n * like bridging custom ERC20\n */\nexport class ZkEVMBridgeAdapter extends BaseToken<IZkEvmClientConfig> {\n\n  constructor(client_: Web3SideChainClient<IZkEvmClientConfig>, address: string, isParent: boolean) {\n    super(\n      {\n        address: address,\n        name: 'ZkEVMBridgeAdapter',\n        bridgeType: 'zkevm',\n        isParent: isParent, // decides if it's a child chain or a root chain adapter\n      },\n      client_,\n    );\n  }\n\n  method(methodName: string, ...args) {\n    return this.getContract().then(contract => {\n      return contract.method(methodName, ...args);\n    });\n  }\n\n  /**\n   * uses the bridge function present in the adapter contract\n   * @param recipient\n   * @param amount\n   * @param forceUpdateGlobalExitRoot\n   * @param option\n   *\n   * @returns\n   * @memberof ZkEvmCustomBridge\n   */\n  bridgeToken(\n    recipient: string,\n    amount: TYPE_AMOUNT,\n    forceUpdateGlobalExitRoot?: boolean,\n    option?: ITransactionOption,\n  ) {\n    return this.method('bridgeToken', recipient, Converter.toHex(amount), forceUpdateGlobalExitRoot).then(\n      method => {\n        return this.processWrite(method, option);\n      },\n    );\n  }\n}\n","import { isHexString } from '@ethereumjs/util';\nimport { ITransactionOption } from \"../interfaces\";\nimport { Converter, Web3SideChainClient, promiseAny } from \"../utils\";\nimport { ZkEvmToken } from \"./zkevm_token\";\nimport { TYPE_AMOUNT } from \"../types\";\nimport { BaseContractMethod } from \"../abstracts\";\nimport { MAX_AMOUNT, ADDRESS_ZERO, DAI_PERMIT_TYPEHASH, EIP_2612_PERMIT_TYPEHASH, UNISWAP_DOMAIN_TYPEHASH, EIP_2612_DOMAIN_TYPEHASH, Permit, BaseContract, BaseWeb3Client, ERROR_TYPE } from '..';\nimport { IAllowanceTransactionOption, IApproveTransactionOption, IBridgeTransactionOption, IZkEvmClientConfig, IZkEvmContracts } from \"../interfaces\";\nimport { ZkEVMBridgeAdapter } from './zkevm_custom_bridge';\n\nexport class ERC20 extends ZkEvmToken {\n    private bridgeAdapter: ZkEVMBridgeAdapter;\n    constructor(\n        tokenAddress: string,\n        isParent: boolean,\n        bridgeAdapterAddress,\n        client: Web3SideChainClient<IZkEvmClientConfig>,\n        getContracts: () => IZkEvmContracts\n    ) {\n        super({\n            isParent,\n            address: tokenAddress,\n            bridgeAdapterAddress,\n            name: 'ERC20',\n            bridgeType: 'zkevm'\n        }, client, getContracts);\n        if (bridgeAdapterAddress) {\n            this.bridgeAdapter = new ZkEVMBridgeAdapter(\n                this.client,\n                bridgeAdapterAddress,\n                isParent\n            );\n        }\n    }\n\n    /**\n     * get bridge for that token\n     *\n     * @returns\n     * @memberof ERC20\n     */\n    getBridgeAddress() {\n        const bridge = this.contractParam.isParent ? this.parentBridge : this.childBridge;\n        return bridge.contractAddress;\n    }\n\n    isEtherToken() {\n        return this.contractParam.address === ADDRESS_ZERO;\n    }\n\n    /**\n     * get token balance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getBalance(userAddress: string, option?: ITransactionOption) {\n        if (this.isEtherToken()) {\n            const client = this.contractParam.isParent ? this.client.parent : this.client.child;\n            return client.getBalance(userAddress);\n        } else {\n            return this.getContract().then(contract => {\n                const method = contract.method(\n                    \"balanceOf\",\n                    userAddress\n                );\n                return this.processRead<string>(method, option);\n            });\n        }\n\n    }\n\n    /**\n     * is Approval needed to bridge tokens to other chains\n     *\n     * @returns\n     * @memberof ERC20\n     */\n    isApprovalNeeded() {\n        if (this.isEtherToken()) {\n            return false;\n        }\n\n        const bridge = this.contractParam.isParent ? this.parentBridge : this.childBridge;\n\n        return bridge.getOriginTokenInfo(this.contractParam.address)\n            .then(tokenInfo => {\n                return tokenInfo[1] === ADDRESS_ZERO;\n            });\n    }\n\n    /**\n     * get allowance of user\n     *\n     * @param {string} userAddress\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    getAllowance(userAddress: string, option: IAllowanceTransactionOption = {}) {\n        this.checkForNonNative(\"getAllowance\");\n        const spenderAddress = option.spenderAddress ? option.spenderAddress : this.getBridgeAddress();\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"allowance\",\n                userAddress,\n                spenderAddress,\n            );\n            return this.processRead<string>(method, option);\n        });\n    }\n\n    /**\n     * Approve given amount of tokens for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {IApproveTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    approve(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        this.checkForNonNative(\"approve\");\n        const spenderAddress = option.spenderAddress ? option.spenderAddress : this.getBridgeAddress();\n\n        return this.getContract().then(contract => {\n            const method = contract.method(\n                \"approve\",\n                spenderAddress,\n                Converter.toHex(amount)\n            );\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * Approve max amount of tokens for user\n     *\n     * @param {IApproveTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    approveMax(option: IApproveTransactionOption = {}) {\n        this.checkForNonNative(\"approveMax\");\n        return this.approve(\n            MAX_AMOUNT,\n            option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    deposit(amount: TYPE_AMOUNT, userAddress: string, option: IBridgeTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n        const permitData = option.permitData || '0x';\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        if (this.isEtherToken()) {\n            option.value = Converter.toHex(amount);\n        }\n\n        return this.childBridge.networkID().then(networkId => {\n            return this.parentBridge.bridgeAsset(\n                networkId,\n                userAddress,\n                amountInABI,\n                this.contractParam.address,\n                forceUpdateGlobalExitRoot,\n                permitData,\n                option\n            );\n        });\n    }\n\n    /**\n     * Deposit given amount of token for user along with ETH for gas token\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositWithGas(amount: TYPE_AMOUNT, userAddress: string, ethGasAmount: TYPE_AMOUNT, option: IBridgeTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        option.value = Converter.toHex(ethGasAmount);\n        if (option.v && option.r && option.s) {\n            return this.zkEVMWrapper.depositPermitWithGas(\n                this.contractParam.address,\n                amountInABI,\n                userAddress,\n                Math.floor((Date.now() + 3600000) / 1000).toString(),\n                option.v,\n                option.r,\n                option.s,\n                option\n            );\n        }\n        return this.zkEVMWrapper.depositWithGas(\n            this.contractParam.address,\n            amountInABI,\n            userAddress,\n            option\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user along with ETH for gas token\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositPermitWithGas(amount: TYPE_AMOUNT, userAddress: string, ethGasAmount: TYPE_AMOUNT, option: IBridgeTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n        this.checkForNonNative(\"getPermitData\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        option.value = Converter.toHex(ethGasAmount);\n\n        return this.getPermitSignatureParams_(amount, this.zkEVMWrapper.contractAddress).then(\n            signatureParams => {\n                return this.zkEVMWrapper.depositPermitWithGas(\n                    this.contractParam.address,\n                    amountInABI,\n                    userAddress,\n                    Math.floor((Date.now() + 3600000) / 1000).toString(),\n                    signatureParams.v,\n                    signatureParams.r,\n                    signatureParams.s,\n                    option\n                );\n            }\n        );\n    }\n\n    /**\n     * Deposit given amount of token for user with permit call\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositWithPermit(amount: TYPE_AMOUNT, userAddress: string, option: IApproveTransactionOption = {}) {\n        this.checkForRoot(\"deposit\");\n        this.checkForNonNative(\"depositWithPermit\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        return this.getPermitData(amountInABI, option).then(permitData => {\n            return this.childBridge.networkID().then(networkId => {\n                return this.parentBridge.bridgeAsset(\n                    networkId,\n                    userAddress,\n                    amountInABI,\n                    this.contractParam.address,\n                    forceUpdateGlobalExitRoot,\n                    permitData,\n                    option\n                );\n            });\n        });\n    }\n\n    /**\n     * Bridge asset to child chain using Custom ERC20 bridge Adapter\n     * @param amount\n     * @param userAddress\n     * @param forceUpdateGlobalExitRoot\n     * @returns\n     * @memberof ERC20\n     */\n    depositCustomERC20(amount: TYPE_AMOUNT, userAddress: string, forceUpdateGlobalExitRoot = true) {\n        // should be allowed to be used only in root chain\n        this.checkForRoot(\"depositCustomERC20\");\n        this.checkAdapterPresent(\"depositCustomERC20\");\n        // should not be allowed to use for native asset\n        this.checkForNonNative(\"depositCustomERC20\");\n        return this.bridgeAdapter.bridgeToken(userAddress, amount, forceUpdateGlobalExitRoot);\n    }\n\n    /**\n     * Claim asset on child chain bridged using custom bridge adapter on root chain\n     * @param transactionHash\n     * @param option\n     * @returns\n     * @memberof ERC20\n     */\n    customERC20DepositClaim(transactionHash: string, option?: ITransactionOption) {\n        this.checkForChild(\"customERC20DepositClaim\");\n        return this.parentBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n                transactionHash, true, networkId\n            );\n        }).then(payload => {\n            return this.childBridge.claimMessage(\n                payload.smtProof,\n                payload.smtProofRollup,\n                payload.globalIndex,\n                payload.mainnetExitRoot,\n                payload.rollupExitRoot,\n                payload.originNetwork,\n                payload.originTokenAddress,\n                payload.destinationNetwork,\n                payload.destinationAddress,\n                payload.amount,\n                payload.metadata,\n                option\n            );\n        });\n    }\n\n\n    /**\n     * Complete deposit after GlobalExitRootManager is synced from Parent to root\n     *\n     * @param {string} transactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    depositClaim(transactionHash: string, option?: ITransactionOption) {\n        this.checkForChild(\"depositClaim\");\n        return this.parentBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n                transactionHash, true, networkId\n            );\n        }).then(payload => {\n            return this.childBridge.claimAsset(\n                payload.smtProof,\n                payload.smtProofRollup,\n                payload.globalIndex,\n                payload.mainnetExitRoot,\n                payload.rollupExitRoot,\n                payload.originNetwork,\n                payload.originTokenAddress,\n                payload.destinationNetwork,\n                payload.destinationAddress,\n                payload.amount,\n                payload.metadata,\n                option\n            );\n        });\n    }\n\n    /**\n     * initiate withdraw by burning provided amount\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdraw(amount: TYPE_AMOUNT, userAddress: string, option: IBridgeTransactionOption = {}) {\n        this.checkForChild(\"withdraw\");\n        const permitData = option.permitData || '0x';\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        if (this.isEtherToken()) {\n            option.value = Converter.toHex(amount);\n        }\n\n        return this.parentBridge.networkID().then(networkId => {\n            return this.childBridge.bridgeAsset(\n                networkId,\n                userAddress,\n                amountInABI,\n                this.contractParam.address,\n                forceUpdateGlobalExitRoot,\n                permitData,\n                option\n            );\n        });\n    }\n\n    /**\n     * Bridge asset to root chain using Custom ERC20 bridge Adapter\n     * @param amount\n     * @param userAddress\n     * @param forceUpdateGlobalExitRoot\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawCustomERC20(amount: TYPE_AMOUNT, userAddress: string, forceUpdateGlobalExitRoot = true) {\n        // should be allowed to be used only in root chain\n        this.checkForChild(\"withdrawCustomERC20\");\n        this.checkAdapterPresent(\"depositCustomERC20\");\n        // should not be allowed to use for native asset\n        this.checkForNonNative(\"withdrawCustomERC20\");\n        return this.bridgeAdapter.bridgeToken(userAddress, amount, forceUpdateGlobalExitRoot);\n    }\n\n    /**\n     * Claim asset on root chain bridged using custom bridge adapter on child chain\n     * @param burnTransactionHash\n     * @param option\n     * @returns\n     * @memberof ERC20\n     */\n    customERC20WithdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"customERC20WithdrawExit\");\n        return this.childBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n                burnTransactionHash, false, networkId\n            );\n        }).then(payload => {\n            return this.parentBridge.claimMessage(\n                payload.smtProof,\n                payload.smtProofRollup,\n                payload.globalIndex,\n                payload.mainnetExitRoot,\n                payload.rollupExitRoot,\n                payload.originNetwork,\n                payload.originTokenAddress,\n                payload.destinationNetwork,\n                payload.destinationAddress,\n                payload.amount,\n                payload.metadata,\n                option\n            );\n        });\n    }\n\n    /**\n     * initiate withdraw by transferring amount with PermitData for native tokens\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} userAddress\n     * @param {IBridgeTransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawWithPermit(amount: TYPE_AMOUNT, userAddress: string, option: IApproveTransactionOption = {}) {\n        this.checkForChild(\"withdraw\");\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const forceUpdateGlobalExitRoot = option.forceUpdateGlobalExitRoot || true;\n\n        return this.getPermitData(amountInABI, option).then(permitData => {\n            return this.parentBridge.networkID().then(networkId => {\n                return this.childBridge.bridgeAsset(\n                    networkId,\n                    userAddress,\n                    amountInABI,\n                    this.contractParam.address,\n                    forceUpdateGlobalExitRoot,\n                    permitData,\n                    option\n                );\n            });\n        });\n    }\n\n    /**\n     * Complete deposit after GlobalExitRootManager is synced from Parent to root\n     *\n     * @param {string} burnTransactionHash\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    withdrawExit(burnTransactionHash: string, option?: ITransactionOption) {\n        this.checkForRoot(\"withdrawExit\");\n        return this.childBridge.networkID().then(networkId => {\n            return this.bridgeUtil.buildPayloadForClaim(\n                burnTransactionHash, false, networkId\n            );\n        }).then(payload => {\n            return this.parentBridge.claimAsset(\n                payload.smtProof,\n                payload.smtProofRollup,\n                payload.globalIndex,\n                payload.mainnetExitRoot,\n                payload.rollupExitRoot,\n                payload.originNetwork,\n                payload.originTokenAddress,\n                payload.destinationNetwork,\n                payload.destinationAddress,\n                payload.amount,\n                payload.metadata,\n                option\n            );\n        });\n    }\n\n    /**\n     * transfer amount to another user\n     *\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} to\n     * @param {ITransactionOption} [option]\n     * @returns\n     * @memberof ERC20\n     */\n    transfer(amount: TYPE_AMOUNT, to: string, option: ITransactionOption = {}) {\n        if (this.contractParam.address === ADDRESS_ZERO) {\n            option.to = to;\n            option.value = Converter.toHex(amount);\n            return this.sendTransaction(option);\n        }\n        return this.transferERC20(to, amount, option);\n    }\n\n    /**\n     * get permitType of the token\n     *\n     * @returns\n     * @memberof ERC20\n     */\n    private getPermit() {\n        let contract: BaseContract;\n        return this.getContract().then(contractInstance => {\n            contract = contractInstance;\n            const method = contract.method(\n                \"PERMIT_TYPEHASH\",\n            );\n            return this.processRead<string>(method);\n        }).then(permitTypehash => {\n            switch (permitTypehash) {\n                case DAI_PERMIT_TYPEHASH: {\n                    return Permit.DAI;\n                }\n                case EIP_2612_PERMIT_TYPEHASH: {\n                    const DOMAIN_TYPEHASH = contract.method(\"DOMAIN_TYPEHASH\");\n                    const EIP712DOMAIN_HASH = contract.method(\"EIP712DOMAIN_HASH\");\n                    return promiseAny([this.processRead<string>(DOMAIN_TYPEHASH), this.processRead<string>(EIP712DOMAIN_HASH)]).then(\n                        (domainTypehash) => {\n                            switch (domainTypehash) {\n                                case EIP_2612_DOMAIN_TYPEHASH: {\n                                    return Permit.EIP_2612;\n                                }\n                                case UNISWAP_DOMAIN_TYPEHASH: {\n                                    return Permit.UNISWAP;\n                                }\n                                default: {\n                                    return Promise.reject(new Error(`Unsupported domain typehash: ${domainTypehash}`));\n                                }\n                            }\n                        }\n                    );\n                }\n                default: {\n                    return Promise.reject(new Error(`Unsupported permit typehash: ${permitTypehash}`));\n                }\n            }\n        });\n    }\n\n    /**\n     * get typedData for signing\n     * @param {string} permitType\n     * @param {string} account\n     * @param {number} chainId\n     * @param {string} name\n     * @param {string} nonce\n     * @param {string} spenderAddress\n     * @param {string} amount\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private getTypedData_(permitType: string, account: string, chainId: number, name: string, nonce: string, spenderAddress: string, amount: string) {\n        const typedData = {\n            types: {\n                EIP712Domain: [\n                    { name: 'name', type: 'string' },\n                    { name: 'version', type: 'string' },\n                    { name: 'chainId', type: 'uint256' },\n                    { name: 'verifyingContract', type: 'address' }\n                ],\n                Permit: []\n            },\n            primaryType: \"Permit\",\n            domain: {\n                name,\n                version: \"1\",\n                chainId,\n                verifyingContract: this.contractParam.address,\n            },\n            message: {}\n        };\n        switch (permitType) {\n            case Permit.DAI:\n                typedData.types.Permit = [\n                    { name: \"holder\", type: \"address\" },\n                    { name: \"spender\", type: \"address\" },\n                    { name: \"nonce\", type: \"uint256\" },\n                    { name: \"expiry\", type: \"uint256\" },\n                    { name: \"allowed\", type: \"bool\" },\n                ];\n                typedData.message = {\n                    holder: account,\n                    spender: spenderAddress,\n                    nonce,\n                    expiry: Math.floor((Date.now() + 3600000) / 1000),\n                    allowed: true,\n                };\n            case Permit.EIP_2612:\n            case Permit.UNISWAP:\n\n                if (permitType === Permit.UNISWAP) {\n                    typedData.types.EIP712Domain = [\n                        { name: 'name', type: 'string' },\n                        { name: 'chainId', type: 'uint256' },\n                        { name: 'verifyingContract', type: 'address' }\n                    ];\n                    delete typedData.domain.version;\n                }\n                typedData.types.Permit = [\n                    { name: 'owner', type: 'address' },\n                    { name: 'spender', type: 'address' },\n                    { name: 'value', type: 'uint256' },\n                    { name: 'nonce', type: 'uint256' },\n                    { name: 'deadline', type: 'uint256' }\n                ];\n                typedData.message = {\n                    owner: account,\n                    spender: spenderAddress,\n                    value: amount,\n                    nonce: nonce,\n                    deadline: Math.floor((Date.now() + 3600000) / 1000),\n                };\n        }\n        return typedData;\n    }\n\n    /**\n     * get {r, s, v} from signature\n     * @param {BaseWeb3Client} client\n     * @param {string} signature\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private getSignatureParameters_(client: BaseWeb3Client, signature: string) {\n        if (!isHexString(signature)) {\n            throw new Error(\n                'Given value \"'.concat(signature, '\" is not a valid hex string.'),\n            );\n        }\n\n        if (signature.slice(0, 2) !== '0x') {\n            signature = '0x'.concat(signature);\n        }\n\n        const r = signature.slice(0, 66);\n        const s = '0x'.concat(signature.slice(66, 130));\n        let v = client.hexToNumber('0x'.concat(signature.slice(130, 132)));\n        if (![27, 28].includes(v as any)) {\n            v += 27;\n        }\n        return {\n            r: r,\n            s: s,\n            v: v,\n        };\n    }\n\n    /**\n     * encode permit function data\n     * @param {BaseContract} contract\n     * @param {string} permitType\n     * @param {any} signatureParams\n     * @param {string} spenderAddress\n     * @param {string} account\n     * @param {string} nonce\n     * @param {string} amount\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private encodePermitFunctionData_(contract: BaseContract, permitType: string, signatureParams: any, spenderAddress: string, account: string, nonce: string, amount: string) {\n        const { r, s, v } = signatureParams;\n        let method: BaseContractMethod;\n        switch (permitType) {\n            case Permit.DAI:\n                method = contract.method(\n                    \"permit\",\n                    account,\n                    spenderAddress,\n                    nonce,\n                    Math.floor((Date.now() + 3600000) / 1000),\n                    true,\n                    v,\n                    r,\n                    s,\n                );\n                break;\n\n            case Permit.EIP_2612:\n            case Permit.UNISWAP:\n                method = contract.method(\n                    \"permit\",\n                    account,\n                    spenderAddress,\n                    amount,\n                    Math.floor((Date.now() + 3600000) / 1000),\n                    v,\n                    r,\n                    s,\n                );\n                break;\n        }\n        return method.encodeABI();\n    }\n\n    private getPermitSignatureParams_(amount: TYPE_AMOUNT, spenderAddress: string) {\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const client = this.contractParam.isParent ? this.client.parent : this.client.child;\n        let account: string;\n        let chainId: number;\n        let permitType: string;\n        let contract: BaseContract;\n        let nonce: string;\n\n        return Promise.all([client.name === 'WEB3' ? client.getAccountsUsingRPC_() : client.getAccounts(), this.getContract(), client.getChainId(), this.getPermit()]).then(result => {\n            account = result[0][0];\n            contract = result[1];\n            chainId = result[2];\n            permitType = result[3];\n            const nameMethod = contract.method(\"name\");\n            const nonceMethod = contract.method(\"nonces\", account);\n            return Promise.all([this.processRead<string>(nameMethod), this.processRead<string>(nonceMethod)]);\n        }).then(data => {\n            const name = data[0];\n            nonce = data[1];\n            return this.getTypedData_(permitType, account, chainId, name, nonce, spenderAddress, amountInABI);\n        }).then(typedData => {\n            return client.signTypedData(account, typedData);\n        }).then(signature => {\n            return this.getSignatureParameters_(client, signature);\n        });\n    }\n\n    /**\n     * Get permit data for given spender for given amount\n     * @param {TYPE_AMOUNT} amount\n     * @param {string} spenderAddress\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    private getPermitData_(amount: TYPE_AMOUNT, spenderAddress: string) {\n\n        const amountInABI = this.client.parent.encodeParameters(\n            [Converter.toHex(amount)],\n            ['uint256'],\n        );\n\n        const client = this.contractParam.isParent ? this.client.parent : this.client.child;\n        let account: string;\n        let chainId: number;\n        let permitType: string;\n        let contract: BaseContract;\n        let nonce: string;\n\n        return Promise.all([client.name === 'WEB3' ? client.getAccountsUsingRPC_() : client.getAccounts(), this.getContract(), client.getChainId(), this.getPermit()]).then(result => {\n            account = result[0][0];\n            contract = result[1];\n            chainId = result[2];\n            permitType = result[3];\n            const nameMethod = contract.method(\"name\");\n            const nonceMethod = contract.method(\"nonces\", account);\n            return Promise.all([this.processRead<string>(nameMethod), this.processRead<string>(nonceMethod)]);\n        }).then(data => {\n            const name = data[0];\n            nonce = data[1];\n            return this.getTypedData_(permitType, account, chainId, name, nonce, spenderAddress, amountInABI);\n        }).then(typedData => {\n            return client.signTypedData(account, typedData);\n        }).then(signature => {\n            const signatureParameters = this.getSignatureParameters_(client, signature);\n            return this.encodePermitFunctionData_(\n                contract, permitType, signatureParameters, spenderAddress, account, nonce, amountInABI\n            );\n        });\n    }\n\n    /**\n     * Get permit data for given amount\n     * @param {TYPE_AMOUNT} amount\n     * @param {IApproveTransactionOption} option\n     * \n     * @returns\n     * @memberof ERC20\n     */\n    getPermitData(amount: TYPE_AMOUNT, option: IApproveTransactionOption = {}) {\n        this.checkForNonNative(\"getPermitData\");\n\n        const spenderAddress = option.spenderAddress ? option.spenderAddress : this.getBridgeAddress();\n\n        return this.getPermitData_(amount, spenderAddress);\n    }\n}\n","import { BaseToken, Web3SideChainClient, Converter, promiseResolve } from \"../utils\";\nimport { IZkEvmClientConfig, ITransactionOption } from \"../interfaces\";\nimport { TYPE_AMOUNT } from \"../types\";\n\nexport class ZkEvmBridge extends BaseToken<IZkEvmClientConfig> {\n\n    networkID_: number;\n\n    constructor(client_: Web3SideChainClient<IZkEvmClientConfig>, address: string, isParent: boolean) {\n        super({\n            address: address,\n            name: 'PolygonZkEVMBridge',\n            bridgeType: 'zkevm',\n            isParent: isParent\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    /**\n     * bridge function to be called on that network from where token is to be transferred to a different network\n     *\n     * @param {string} token Token address\n     * @param {number} destinationNetwork Network at which tokens will be bridged\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {TYPE_AMOUNT} amountamount amount of tokens\n     * @param {string} [permitData] Permit data to avoid approve call\n     * @param {ITransactionOption} [option] \n     * \n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    bridgeAsset(\n        destinationNetwork: number,\n        destinationAddress: string,\n        amount: TYPE_AMOUNT,\n        token: string,\n        forceUpdateGlobalExitRoot: boolean,\n        permitData = '0x',\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"bridgeAsset\",\n            destinationNetwork,\n            destinationAddress,\n            Converter.toHex(amount),\n            token,\n            forceUpdateGlobalExitRoot,\n            permitData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * Claim function to be called on the destination network\n     *\n     * @param {string[]} smtProof Merkle Proof\n     * @param {string[]} smtProofRollup Roll up Merkle Proof\n     * @param {string} globalIndex Global Index\n     * @param {string} mainnetExitRoot Mainnet Exit Root\n     * @param {string} rollupExitRoot RollUP Exit Root\n     * @param {number} originNetwork Network at which token was initially deployed\n     * @param {string} originTokenAddress Address of token at network where token was initially deployed\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {TYPE_AMOUNT} amount amount of tokens\n     * @param {string} [metadata] Metadata of token\n     * @param {ITransactionOption} [option]\n     * \n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    claimAsset(\n        smtProof: string[],\n        smtProofRollup: string[],\n        globalIndex: string,\n        mainnetExitRoot: string,\n        rollupExitRoot: string,\n        originNetwork: number,\n        originTokenAddress: string,\n        destinationNetwork: number,\n        destinationAddress: string,\n        amount: TYPE_AMOUNT,\n        metadata: string,\n        option: ITransactionOption\n    ) {\n        return this.method(\n            \"claimAsset\",\n            smtProof,\n            smtProofRollup,\n            globalIndex,\n            mainnetExitRoot,\n            rollupExitRoot,\n            originNetwork,\n            originTokenAddress,\n            destinationNetwork,\n            destinationAddress,\n            amount,\n            metadata\n        ).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    /**\n     * bridge function to be called on that network from where message is to be transferred to a different network\n     * @param {number} destinationNetwork Network at which tokens will be bridged\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {boolean} forceUpdateGlobalExitRoot Indicates if the new global exit root is updated or not\n     * @param {string} [permitData] Permit data to avoid approve call\n     * @param {ITransactionOption} [option]\n     *\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    bridgeMessage(\n        destinationNetwork: number,\n        destinationAddress: string,\n        forceUpdateGlobalExitRoot: boolean,\n        permitData = '0x',\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"bridgeMessage\",\n            destinationNetwork,\n            destinationAddress,\n            forceUpdateGlobalExitRoot,\n            permitData\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    /**\n     * Claim Message new function to be called on the destination network\n     * If the receiving address is an EOA, the call will result as a success\n     * Which means that the amount of ether will be transferred correctly, but the message\n     * will not trigger any execution. this will work after Etrog changes\n     * @param {string[]} smtProof Merkle Proof\n     * @param {string[]} smtProofRollup Roll up Merkle Proof\n     * @param {string} globalIndex Global Index\n     * @param {string} mainnetExitRoot Mainnet Exit Root\n     * @param {string} rollupExitRoot RollUP Exit Root\n     * @param {number} originNetwork Network at which token was initially deployed\n     * @param {string} originTokenAddress Address of token at network where token was initially deployed\n     * @param {string} destinationAddress Address to which tokens will be bridged\n     * @param {TYPE_AMOUNT} amount amount of tokens\n     * @param {string} [metadata] Metadata of token\n     * @param {ITransactionOption} [option]\n     *\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    claimMessage(\n        smtProof: string[],\n        smtProofRollup: string[],\n        globalIndex: string,\n        mainnetExitRoot: string,\n        rollupExitRoot: string,\n        originNetwork: number,\n        originTokenAddress: string,\n        destinationNetwork: number,\n        destinationAddress: string,\n        amount: TYPE_AMOUNT,\n        metadata: string,\n        option: ITransactionOption) {\n        return this.method(\n            \"claimMessage\",\n            smtProof,\n            smtProofRollup,\n            globalIndex,\n            mainnetExitRoot,\n            rollupExitRoot,\n            originNetwork,\n            originTokenAddress,\n            destinationNetwork,\n            destinationAddress,\n            amount,\n            metadata\n        ).then(method => {\n            return this.processWrite(\n                method,\n                option\n            );\n        });\n    }\n\n    /**\n     * get the address of token which is created by the bridge contract on the non origin chain\n     *\n     * @param {number} originNetwork Network at which the token was initially deployed\n     * @param {string} originTokenAddress Address at the network where token was initially deployed\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    getMappedTokenInfo(\n        originNetwork: number,\n        originTokenAddress: string\n    ) {\n        return this.method(\n            \"getTokenWrappedAddress\", originNetwork, originTokenAddress\n        ).then(method => {\n            return this.processRead<string>(method);\n        });\n    }\n\n    /**\n     * Tells if claim has already happed or not based on the deposit index\n     *\n     * @param {number} index\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    isClaimed(\n        index: number,\n        sourceBridgeNetwork: number\n    ) {\n        return this.method(\n            \"isClaimed\", index, sourceBridgeNetwork\n        ).then(method => {\n            return this.processRead<string>(method);\n        });\n    }\n\n    /**\n     * Even if the wrapped contract is not deployed on the destination chain, it will tell us the address which is going to be.\n     *\n     * @param {number} originNetwork Network at which the token was initially deployed\n     * @param {string} originTokenAddress Address at the network where token was initially deployed\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    precalculatedMappedTokenInfo(\n        originNetwork: number,\n        originTokenAddress: string\n    ) {\n        return this.method(\n            \"precalculatedWrapperAddress\", originNetwork, originTokenAddress\n        ).then(method => {\n            return this.processRead<string>(method);\n        });\n    }\n\n    /**\n     * get the address and network of the wrapped token where it was emerged initially\n     *\n     * @param {number} wrappedToken\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    getOriginTokenInfo(wrappedToken: string) {\n        return this.method(\n            \"wrappedTokenToTokenInfo\", wrappedToken\n        ).then(method => {\n            return this.processRead<[number, string]>(method);\n        });\n    }\n\n    /**\n     * get the network ID for chain in which the bridge contract is deployed\n     *\n     * @returns\n     * @memberof ZkEvmBridge\n     */\n    networkID() {\n        if (this.networkID_) {\n            return promiseResolve<number>(this.networkID_ as any);\n        }\n        return this.method(\n            \"networkID\"\n        ).then(method => {\n            return this.processRead<number>(method).then((networkId) => {\n                this.networkID_ = networkId;\n                return networkId;\n            });\n        });\n    }\n\n}\n","import { Web3SideChainClient } from \"../utils\";\nimport { service } from \"../services\";\nimport { IBaseClientConfig, _GLOBAL_INDEX_MAINNET_FLAG } from \"..\";\nimport { TYPE_AMOUNT } from '../types';\n\ninterface IBridgeEventInfo {\n    originNetwork: number;\n    originTokenAddress: string;\n    destinationNetwork: number;\n    destinationAddress: string;\n    amount: TYPE_AMOUNT;\n    metadata: string;\n    depositCount: number;\n}\n\ninterface IMerkleProof {\n    merkle_proof: string[];\n    rollup_merkle_proof?: string[];\n    exit_root_num: string;\n    l2_exit_root_num: string;\n    main_exit_root: string;\n    rollup_exit_root: string;\n}\n\ninterface IClaimPayload {\n    smtProof: string[];\n    smtProofRollup: string[];\n    globalIndex: string;\n    mainnetExitRoot: string;\n    rollupExitRoot: string;\n    originNetwork: number;\n    originTokenAddress: string;\n    destinationNetwork: number;\n    destinationAddress: string;\n    amount: TYPE_AMOUNT;\n    metadata: string;\n}\n\nexport class BridgeUtil {\n    private client_: Web3SideChainClient<IBaseClientConfig>;\n    private BRIDGE_TOPIC = \"0x501781209a1f8899323b96b4ef08b168df93e0a90c673d1e4cce39366cb62f9b\";\n\n    constructor(client: Web3SideChainClient<IBaseClientConfig>) {\n        this.client_ = client;\n    }\n\n    private decodedBridgeData_(data: string, isParent: boolean) {\n        const client = isParent ? this.client_.parent : this.client_.child;\n        return this.client_.getABI(\"PolygonZkEVMBridge\", \"zkevm\").then(abi => {\n            const types = abi.filter(event => event.name === \"BridgeEvent\");\n            if (!types.length) {\n                throw new Error(\"Data not decoded\");\n            }\n            const decodedData = client.decodeParameters(data, types[0].inputs);\n            const [leafType, originNetwork, originTokenAddress, destinationNetwork, destinationAddress, amount, metadata, depositCount] = decodedData;\n            return {\n                leafType,\n                originNetwork,\n                originTokenAddress,\n                destinationNetwork,\n                destinationAddress,\n                amount,\n                metadata: metadata || '0x',\n                depositCount,\n            } as IBridgeEventInfo;\n        });\n    }\n\n    private getBridgeLogData_(transactionHash: string, isParent: boolean) {\n        const client = isParent ? this.client_.parent : this.client_.child;\n        return client.getTransactionReceipt(transactionHash)\n            .then(receipt => {\n                const logs = receipt.logs.filter(log => log.topics[0].toLowerCase() === this.BRIDGE_TOPIC);\n                if (!logs.length) {\n                    throw new Error(\"Log not found in receipt\");\n                }\n\n                const data = logs[0].data;\n                return this.decodedBridgeData_(data, isParent);\n            });\n    }\n\n    private getProof_(networkId: number, depositCount: number) {\n        return service.zkEvmNetwork.getMerkleProofForZkEvm(\n            this.client_.config.version,\n            networkId,\n            depositCount,\n        ).then(proof => {\n            return proof as IMerkleProof;\n        }).catch(_ => {\n            throw new Error(\"Error in creating proof\");\n        });\n    }\n\n    getBridgeLogData(transactionHash: string, isParent: boolean) {\n        return this.getBridgeLogData_(transactionHash, isParent);\n    }\n\n    computeGlobalIndex(indexLocal: number, indexRollup: number, sourceNetworkId: number) {\n        if (BigInt(sourceNetworkId) === BigInt(0)) {\n            return BigInt(indexLocal) + _GLOBAL_INDEX_MAINNET_FLAG;\n        } else {\n            return BigInt(indexLocal) + BigInt(indexRollup) * BigInt(2 ** 32);\n        }\n    }\n\n    buildPayloadForClaim(transactionHash: string, isParent: boolean, networkId: number) {\n        return this.getBridgeLogData_(transactionHash, isParent).then(data => {\n            const {\n                originNetwork,\n                originTokenAddress,\n                destinationNetwork,\n                destinationAddress,\n                amount,\n                metadata,\n                depositCount } = data;\n            return this.getProof_(networkId, depositCount).then(proof => {\n                const payload = {} as IClaimPayload;\n                payload.smtProof = proof.merkle_proof;\n                payload.smtProofRollup = proof.rollup_merkle_proof;\n                payload.globalIndex = this.computeGlobalIndex(depositCount, destinationNetwork, networkId).toString();\n                payload.mainnetExitRoot = proof.main_exit_root;\n                payload.rollupExitRoot = proof.rollup_exit_root;\n                payload.originNetwork = originNetwork;\n                payload.originTokenAddress = originTokenAddress;\n                payload.destinationNetwork = destinationNetwork;\n                payload.destinationAddress = destinationAddress;\n                payload.amount = amount;\n                payload.metadata = metadata;\n                return payload;\n            });\n        });\n    }\n}\n","import { BaseToken, Web3SideChainClient } from \"../utils\";\nimport { IZkEvmClientConfig, ITransactionOption } from \"../interfaces\";\n\nexport class ZkEVMWrapper extends BaseToken<IZkEvmClientConfig> {\n\n    constructor(client_: Web3SideChainClient<IZkEvmClientConfig>, address: string) {\n        super({\n            address: address,\n            name: 'ZkEVMWrapper',\n            bridgeType: 'zkevm',\n            isParent: true\n        }, client_);\n    }\n\n    method(methodName: string, ...args) {\n        return this.getContract().then(contract => {\n            return contract.method(methodName, ...args);\n        });\n    }\n\n    depositWithGas(\n        tokenAddress: string,\n        depositAmount: string,\n        userAddress: string,\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"deposit\",\n            tokenAddress,\n            depositAmount,\n            userAddress,\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n    depositPermitWithGas(\n        tokenAddress: string,\n        depositAmount: string,\n        userAddress: string,\n        deadline: string,\n        v: number,\n        r: string,\n        s: string,\n        option?: ITransactionOption\n    ) {\n        return this.method(\n            \"deposit\",\n            tokenAddress,\n            depositAmount,\n            userAddress,\n            deadline,\n            v,\n            r,\n            s\n        ).then(method => {\n            return this.processWrite(method, option);\n        });\n    }\n\n}\n","import { ERC20 } from \"./erc20\";\nimport { ZkEvmBridge } from \"./zkevm_bridge\";\nimport { BridgeUtil } from \"./bridge_util\";\nimport { ZkEvmBridgeClient } from \"../utils\";\nimport { IZkEvmClientConfig, IZkEvmContracts } from \"../interfaces\";\nimport { config as urlConfig } from \"../config\";\nimport { service, NetworkService } from \"../services\";\nimport { ZkEVMWrapper } from \"./zkevm_wrapper\";\n\nexport * from \"./zkevm_bridge\";\nexport * from \"./bridge_util\";\nexport * from \"./zkevm_wrapper\";\n\nexport class ZkEvmClient extends ZkEvmBridgeClient {\n\n    zkEVMWrapper: ZkEVMWrapper;\n\n    init(config: IZkEvmClientConfig) {\n        const client = this.client;\n\n        return client.init(config).then(_ => {\n            const mainZkEvmContracts = client.mainZkEvmContracts;\n            const zkEvmContracts = client.zkEvmContracts;\n            client.config = config = Object.assign(\n                {\n                    parentBridge: mainZkEvmContracts.PolygonZkEVMBridgeProxy,\n                    childBridge: zkEvmContracts.PolygonZkEVMBridge,\n                    zkEVMWrapper: mainZkEvmContracts.ZkEVMWrapper\n                } as IZkEvmClientConfig,\n                config\n            );\n\n            this.rootChainBridge = new ZkEvmBridge(\n                this.client,\n                config.parentBridge,\n                true\n            );\n\n            this.childChainBridge = new ZkEvmBridge(\n                this.client,\n                config.childBridge,\n                false\n            );\n\n            this.zkEVMWrapper = new ZkEVMWrapper(\n                this.client,\n                config.zkEVMWrapper\n            );\n\n            this.bridgeUtil = new BridgeUtil(\n                this.client\n            );\n\n            if (!service.zkEvmNetwork) {\n                if (urlConfig.zkEvmBridgeService[urlConfig.zkEvmBridgeService.length - 1] !== '/') {\n                    urlConfig.zkEvmBridgeService += '/';\n                }\n                urlConfig.zkEvmBridgeService += 'api/zkevm/';\n                service.zkEvmNetwork = new NetworkService(urlConfig.zkEvmBridgeService);\n            }\n\n            return this;\n        });\n    }\n\n    /**\n     * creates instance of ERC20 token\n     *\n     * @param {string} tokenAddress\n     * @param {boolean} isParent\n     *\n     * @param bridgeAdapterAddress Needed if a custom erc20 token is being bridged\n     * @returns\n     * @memberof ERC20\n     */\n    erc20(tokenAddress: string, isParent?: boolean, bridgeAdapterAddress?: string) {\n        return new ERC20(\n            tokenAddress,\n            isParent,\n            bridgeAdapterAddress,\n            this.client,\n            this.getContracts_.bind(this)\n        );\n    }\n\n    private getContracts_() {\n        return {\n            parentBridge: this.rootChainBridge,\n            childBridge: this.childChainBridge,\n            bridgeUtil: this.bridgeUtil,\n            zkEVMWrapper: this.zkEVMWrapper\n        } as IZkEvmContracts;\n    }\n}\n","import { defaultExport } from \"./default\";\n\nexport * from \"./utils\";\nexport * from \"./enums\";\nexport * from \"./pos\";\nexport * from \"./interfaces\";\nexport * from \"./types\";\nexport * from \"./constant\";\nexport * from \"./abstracts\";\nexport * from \"./services\";\nexport * from \"./zkevm\";\n\nexport default defaultExport;\n"],"names":["root","factory","exports","module","require","define","amd","self","__WEBPACK_EXTERNAL_MODULE__335__","__WEBPACK_EXTERNAL_MODULE__18__","__WEBPACK_EXTERNAL_MODULE__773__","__WEBPACK_EXTERNAL_MODULE__514__","__WEBPACK_EXTERNAL_MODULE__935__","__WEBPACK_EXTERNAL_MODULE__804__","__WEBPACK_EXTERNAL_MODULE__858__","__WEBPACK_EXTERNAL_MODULE__849__","buffer","Buffer","copyProps","src","dst","key","SafeBuffer","arg","encodingOrOffset","length","from","alloc","allocUnsafe","allocUnsafeSlow","TypeError","size","fill","encoding","buf","undefined","SlowBuffer","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","Log_Event_Signature","ERROR_TYPE","logger","getRootHash","startBlock","endBlock","this","sendRPCRequest","jsonrpc","method","params","Number","id","Date","getTime","payload","result","String","Error","getAccountsUsingRPC_","then","address","isBN","throwNotImplemented","toString","base","toNumber","add","sub","mul","div","lte","lt","gte","gt","eq","BaseBigNumber","toHex","amount","dataType","utils","BN","slice","toBN","parseInt","use","plugin","pluginInstance","setup","defaultExport","eventBusPromise","executor","promise","Promise","eventBus","EventBus","on","bind","emit","ctx","_events","_ctx","event","cb","push","off","index","indexOf","splice","events","all","map","args","resolve","destroy","type","info","message","getMsg_","throw","errMsg","AllowedOnChild","AllowedOnRoot","AllowedOnMainnet","ProofAPINotSet","BurnTxNotCheckPointed","EIP1559NotSupported","NullSpenderAddress","Unknown","enableLog","isEnabled","log","console","error","ErrorHelper","merge","assign","runPromises","promises","converter","maps","val","mapPromise","values","option","valuesLength","concurrency","limitPromiseRun","promiseResult","concat","promiseResolve","number","isSafeInteger","bytes","b","lengths","Uint8Array","constructor","name","includes","exists","instance","checkFinished","destroyed","finished","output","out","min","outputLen","bool","hash","h","create","blockLen","U32_MASK64","BigInt","_32n","fromBig","le","l","split","lst","Ah","Uint32Array","Al","i","isLE","byteSwap32","arr","word","toBytes","data","str","TextEncoder","encode","utf8ToBytes","Hash","clone","_cloneInto","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","round","R","x","y","t","j","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","s","rotlBH","rotlSH","rotlL","rotlBL","rotlSL","Keccak","suffix","enableXOF","rounds","super","pos","posOut","state","state32","byteOffset","Math","floor","byteLength","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","keccakP","update","len","take","finish","writeInto","bufferOut","set","subarray","xofInto","xof","digestInto","digest","to","gen","hashCons","hashC","msg","tmp","wrapConstructor","keccak_224","keccak_256","keccak_384","keccak_512","wrapHash","webCrypto","globalThis","crypto","nodeRequire","keccak224","keccak256","k","keccak384","keccak512","Permit","assertIsBuffer","input","isBuffer","bits","sha3","leaves","depth","ceil","Array","pow","zeros","layers","createHashes","nodes","treeLevel","left","right","getLeaves","getLayers","getRoot","getProof","leaf","compare","proof","siblingIndex","verify","isArray","node","padToEven","isHexPrefixed","isHexString","match","intToHex","stripHexPrefix","BufferUtil","intToBuffer","hex","toBuffer","v","isNeg","toArrayLike","toArray","bufferToHex","getFastMerkleProof","web3","blockNumber","merkleTreeDepth","log2","reversedProof","targetIndex","offset","leftBound","rightBound","nLeaves","pivotLeaf","newLeftBound","queryRootHash","subTreeMerkleRoot","newRightBound","expectedHeight","recursiveZeroHash","subTreeHeight","heightDifference","remainingNodesHash","MerkleTree","reverse","buildBlockProof","maticWeb3","ProofUtil","p","client","rootHash","catch","_","subHash","encodeParameters","getReceiptProof","receipt","block","requestConcurrency","receiptsVal","receiptPromise","stateSyncTxHash","getStateSyncTxHash","receiptsTrie","transactions","forEach","tx","transactionHash","getTransactionReceipt","receipts","siblingReceipt","path","transactionIndex","rawReceipt","getReceiptBytes","put","findPath","remaining","prf","blockHash","parentNodes","stack","raw","getRawHeader","receiptTrie","isTypedReceipt","e","getPrfValue","hexType","Converter","status","setLengthLeft","encodedData","cumulativeGasUsed","logsBloom","logs","topics","_block","difficulty","common","Common","chain","Chain","Mainnet","hardfork","Hardfork","London","BlockHeader","fromHeaderData","skipConsensusFormatValidation","fetch","process","env","BUILD_ENV","window","baseUrl","url","query","keys","encodeURIComponent","join","headers","res","json","post","body","JSON","stringify","chainIdToConfigPath","Logger","init","config","parent","defaultConfig","child","Web3Client","UnstoppableDomains","resolution","provider","network","version","abiManager","ABIManager","err","getABI","getConfig","isEIP1559Supported","chainId","promiseAny","promisesArray","promiseErrors","counter","reject","MAX_AMOUNT","ADDRESS_ZERO","DAI_PERMIT_TYPEHASH","EIP_2612_PERMIT_TYPEHASH","EIP_2612_DOMAIN_TYPEHASH","UNISWAP_DOMAIN_TYPEHASH","_GLOBAL_INDEX_MAINNET_FLAG","contractParam","getContract","contract_","bridgeType","abi","getContract_","isParent","tokenAddress","getChainId","chainId_","getClient","processWrite","validateTxOption_","createTransactionConfig","txConfig","isWrite","returnTransaction","encodeABI","write","sendTransaction","readTransaction","read","TransactionOptionNotObject","processRead","parentDefaultConfig","childDefaultConfig","clientChainId","maxFeePerGas","maxPriorityFeePerGas","isMaxFeeProvided","gasLimit","estimateGas","trunc","nonce","getTransactionCount","transferERC20","contract","transferERC721","tokenId","checkForNonNative","methodName","AllowedOnNonNativeTokens","checkForRoot","checkForChild","checkAdapterPresent","bridgeAdapterAddress","BridgeAdapterNotFound","transferERC1155","param","httpRequest","HttpRequest","contractName","getAddress","abiStoreUrl","zkEvmBridgeService","createUrlForPos","createUrlForZkEvm","getBlockIncluded","headerBlockNumber","decimalHeaderBlockNumber","getExitProof","burnTxHash","eventSignature","start","end","getMerkleProofForZkEvm","networkID","depositCount","getBridgeTransactionDetails","deposit","service","ABIService","setProofApi","NetworkService","setZkEvmProofApi","zkEvmNetwork","reduce","prev","curr","Web3SideChainClient","isCheckPointed","txHash","exitUtil","isDeposited","depositTxHash","token","BaseToken","lastStateId","targetLog","find","q","rootStateId","decodeParameters","rootStateIdBN","cache","networkName","targetBridgeABICache","abiForContract","setABI","abiStore","isDepositClaimable","rootChainBridge","bridgeUtil","getBridgeLogData","details","ready_for_claim","isWithdrawExitable","childChainBridge","isClaimed","isExited","BaseWeb3Client","EmptyBigNumber","getPOSContracts","rootChainManager","gasSwapper","getPredicateAddress","predicateAddress","tokenType","typeToPredicateMethod","isWithdrawn","getExitHash","exitHash","isExitProcessed","isWithdrawnOnIndex","withdrawExitPOS","isFast","buildPayloadForExit","exit","getContracts","getBalance","userAddress","getAllowance","spenderAddress","predicatePromise","approve","approveMax","amountInABI","depositWithGas","swapEthAmount","swapCallData","depositEther_","depositEtherWithGas_","withdrawStart","withdrawExit_","burnTransactionHash","burnEventSignature","Erc20Transfer","withdrawExit","withdrawExitFaster","isWithdrawExited","transfer","POSToken","client_","depositData","exitPayload","rootChain","maticClient_","getLogIndex_","logEventSig","logIndex","findIndex","toLowerCase","getAllLogIndices_","logIndices","getChainBlockInfo","getLastChildBlock","getTransaction","lastChildBlock","txBlockNumber","isCheckPointed_","getRootBlockInfo","rootBlockNumber","findRootBlockFromChild","rootBlockInfo","getRootBlockInfoFromAPI","headerBlock","getBlockProof","getBlockProofFromAPI","blockProof","getExitProofFromAPI","burnHash","exitProof","blockInfo","getBlockWithTransaction","rootBlockInfoResult","blockProofResult","receiptProof","encodePayload_","timestamp","transactionsRoot","receiptsRoot","buildMultiplePayloadsForExit","payloads","headerNumber","receiptParentNodes","blockResult","nibbleArr","byte","etheriumSha3","rootChainDefaultBlock","childBlockNumber","bigOne","bigtwo","checkPointInterval","currentHeaderBlock","ans","mid","headerStart","headerEnd","validateMany_","tokenIds","getTokensCount","options","count","getTokenIdAtIndexForUser","getAllTokens","limit","isApproved","isApprovedAll","approveAll","depositMany","tokensInHex","withdrawStartWithMetaData","withdrawStartMany","Erc721Transfer","withdrawExitOnIndex","isWithdrawExitedMany","Erc721BatchTransfer","isWithdrawExitedOnIndex","erc1155","getAddress_","addresses","addressConfig","approveAll_","predicateAddressPromise","approveAllForMintable","amounts","emptyHex","amountsInHex","Erc1155Transfer","withdrawExitMany","Erc1155BatchTransfer","withdrawExitFasterMany","depositAmount","mainPOSContracts","RootChainManagerProxy","mainPlasmaContracts","RootChainProxy","GasSwapper","RootChainManager","RootChain","ExitUtil","erc20","ERC20","getContracts_","erc721","ERC721","ERC1155","depositEther","depositEtherWithGas","BridgeClient","POSClient","getZkEvmContracts","parentBridge","zkEVMWrapper","childBridge","bridgeToken","recipient","forceUpdateGlobalExitRoot","bridgeAdapter","ZkEVMBridgeAdapter","getBridgeAddress","contractAddress","isEtherToken","isApprovalNeeded","getOriginTokenInfo","tokenInfo","permitData","networkId","bridgeAsset","ethGasAmount","depositPermitWithGas","now","getPermitSignatureParams_","signatureParams","depositWithPermit","getPermitData","depositCustomERC20","customERC20DepositClaim","buildPayloadForClaim","claimMessage","smtProof","smtProofRollup","globalIndex","mainnetExitRoot","rollupExitRoot","originNetwork","originTokenAddress","destinationNetwork","destinationAddress","metadata","depositClaim","claimAsset","withdraw","withdrawCustomERC20","customERC20WithdrawExit","withdrawWithPermit","getPermit","contractInstance","permitTypehash","DAI","DOMAIN_TYPEHASH","EIP712DOMAIN_HASH","domainTypehash","EIP_2612","UNISWAP","getTypedData_","permitType","account","typedData","types","EIP712Domain","primaryType","domain","verifyingContract","holder","spender","expiry","allowed","owner","deadline","getSignatureParameters_","signature","hexToNumber","encodePermitFunctionData_","getAccounts","nameMethod","nonceMethod","signTypedData","getPermitData_","signatureParameters","ZkEvmToken","bridgeMessage","getMappedTokenInfo","sourceBridgeNetwork","precalculatedMappedTokenInfo","wrappedToken","networkID_","BRIDGE_TOPIC","decodedBridgeData_","filter","decodedData","inputs","leafType","getBridgeLogData_","getProof_","computeGlobalIndex","indexLocal","indexRollup","sourceNetworkId","merkle_proof","rollup_merkle_proof","main_exit_root","rollup_exit_root","mainZkEvmContracts","zkEvmContracts","PolygonZkEVMBridgeProxy","PolygonZkEVMBridge","ZkEVMWrapper","ZkEvmBridge","BridgeUtil","ZkEvmBridgeClient"],"sourceRoot":""}